(() => {
  // jsOMS/Utils/oLib.js
  var jsOMS2 = class _jsOMS {
    /**
     * Trigger an event
     *
     * @param {Element} element Element where the event is assigned
     * @param {string}  eventName Name of the event
     *
     * @return void
     *
     * @function
     *
     * @since 1.0.0
     */
    static triggerEvent = function(element, eventName) {
      if (document.createEvent) {
        const event = document.createEvent("HTMLEvents");
        event.initEvent(eventName, true, true);
        event.eventName = eventName;
        element.dispatchEvent(event);
      } else {
        const event = document.createEventObject();
        event.eventName = eventName;
        event.eventType = eventName;
        element.fireEvent(event.eventType, event);
      }
    };
    /**
     * Trim char from string
     *
     * @param {string} path    Array path
     * @param {Object} data    Object
     * @param {string} [delim] Path delimiter
     *
     * @return {any}
     *
     * @function
     *
     * @since 1.0.0
     */
    static getArray = function(path, data, delim = "/") {
      const pathParts = _jsOMS.ltrim(path, delim).split(delim);
      let current = data;
      for (const key in pathParts) {
        if (!Object.prototype.hasOwnProperty.call(pathParts, key)) {
          continue;
        }
        if (typeof current === "undefined" || !Object.prototype.hasOwnProperty.call(current, pathParts[key])) {
          return null;
        }
        current = current[pathParts[key]];
      }
      return current;
    };
    /**
     * Trim char from string
     *
     * @param {string} str    String to trim from
     * @param {string} [char] Char to trim
     *
     * @return {string}
     *
     * @function
     *
     * @since 1.0.0
     */
    static trim = function(str, char = " ") {
      return _jsOMS.ltrim(_jsOMS.rtrim(str, char), char);
    };
    /**
     * Trim char from right part of string
     *
     * @param {string} str    String to trim from
     * @param {string} [char] Char to trim
     *
     * @return {string}
     *
     * @function
     *
     * @since 1.0.0
     */
    static rtrim = function(str, char = " ") {
      return str.replace(new RegExp("[" + char + "]*$"), "");
    };
    /**
     * Trim char from left part of string
     *
     * @param {string} str    String to trim from
     * @param {string} [char] Char to trim
     *
     * @return {string}
     *
     * @function
     *
     * @since 1.0.0
     */
    static ltrim = function(str, char = " ") {
      return str.replace(new RegExp("^[" + char + "]*"), "");
    };
    static htmlspecialchars = [
      ["&", "&amp;"],
      ["<", "&lt;"],
      [">", "&gt;"],
      ['"', "&quot;"]
    ];
    /**
     * Encode none-html string
     *
     * @param {string} str String to encode
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static htmlspecialchars_encode = function(str) {
      let escaped = str;
      const length = _jsOMS.htmlspecialchars.length;
      for (let i = 0; i < length; ++i) {
        escaped = escaped.replace(
          new RegExp(_jsOMS.htmlspecialchars[i][0], "g"),
          _jsOMS.htmlspecialchars[i][1]
        );
      }
      return escaped;
    };
    /**
     * Decode html string
     *
     * @param {string} str String to encode
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static htmlspecialchars_decode = function(str) {
      let decoded = str;
      const length = _jsOMS.htmlspecialchars.length;
      for (let i = 0; i < length; ++i) {
        decoded = decoded.replace(
          new RegExp(_jsOMS.htmlspecialchars[i][1], "g"),
          _jsOMS.htmlspecialchars[i][0]
        );
      }
      return decoded;
    };
    /**
     * Count string in string
     *
     * @param {string} str String to inspect
     * @param {string} substr Substring to count
     *
     * @return {number}
     *
     * @function
     *
     * @since 1.0.0
     */
    static substr_count = function(str, substr) {
      str += "";
      substr += "";
      if (substr.length <= 0) {
        return str.length + 1;
      }
      let n = 0;
      let pos = 0;
      const step = substr.length;
      while (true) {
        pos = str.indexOf(substr, pos);
        if (pos >= 0) {
          ++n;
          pos += step;
        } else {
          break;
        }
      }
      return n;
    };
    /**
     * Class finder
     *
     * Checking if a element has a class
     *
     * @param {Element} ele DOM Element
     * @param {string}  cls Class to find
     *
     * @return {boolean}
     *
     * @function
     *
     * @since 1.0.0
     */
    static hasClass = function(ele, cls) {
      return typeof ele !== "undefined" && ele !== null && (typeof ele.className === "string" && ele.className.match(new RegExp("(\\s|^)" + cls + "(\\s|$)")) !== null || typeof ele.className.baseVal === "string" && ele.className.baseVal.match(new RegExp("(\\s|^)" + cls + "(\\s|$)")) !== null);
    };
    /**
     * Add class
     *
     * Adding a class to an element
     *
     * @param {Element} DOM Element
     * @param {string}  Class to add
     *
     * @return {void}
     *
     * @function
     *
     * @since 1.0.0
     */
    static addClass = function(ele, cls) {
      if (!_jsOMS.hasClass(ele, cls)) {
        if (typeof ele.className === "string") {
          ele.className += ele.className !== "" ? " " + cls : cls;
        } else if (typeof ele.className.baseVal === "string") {
          ele.className.baseVal += ele.className.baseVal !== "" ? " " + cls : cls;
        }
      }
    };
    /**
     * Remove class
     *
     * Removing a class form an element
     *
     * @param {Element} DOM Element
     * @param {string}  Class to remove
     *
     * @return {void}
     *
     * @function
     *
     * @since 1.0.0
     */
    static removeClass = function(ele, cls) {
      if (_jsOMS.hasClass(ele, cls)) {
        const reg = new RegExp("(\\s|^)" + cls);
        if (typeof ele.className === "string") {
          ele.className = ele.className.replace(reg, "").trim();
        } else if (typeof ele.className.baseVal === "string") {
          ele.className.baseVal = ele.className.baseVal.replace(reg, "").trim();
        }
      }
    };
    /**
     * Delayed watcher
     *
     * Used to fire event after delay
     *
     * @return {callback}
     *
     * @function
     *
     * @since 1.0.0
     */
    static watcher = function() {
      let watcherTimer = 0;
      return function(callback, ms) {
        clearTimeout(watcherTimer);
        watcherTimer = setTimeout(callback, ms);
      };
    }();
    /**
     * Action prevent
     *
     * Preventing event from firering and passing through
     *
     * @param {Event} Event Event to stop
     *
     * @return {boolean}
     *
     * @function
     *
     * @since 1.0.0
     */
    static preventAll = function(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      event.stopPropagation();
      event.cancelBubble = true;
      return false;
    };
    /**
     * Ready invoke
     *
     * Invoking a function after page load
     *
     * @param {function} Callback function
     *
     * @return {void}
     *
     * @function
     *
     * @since 1.0.0
     */
    static ready = function(func) {
      if (document.readyState === "complete" || document.readyState === "loaded" || document.readyState === "interactive") {
        func();
      } else {
        document.addEventListener("DOMContentLoaded", function(event) {
          func();
        });
      }
    };
    /**
     * Get element value
     *
     * @param {Element} DOM Element
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static getValue = function(ele) {
      switch (ele.tagName.toLowerCase()) {
        case "div":
        case "pre":
        case "article":
        case "section":
          return ele.innerHTML;
        default:
          return ele.value;
      }
    };
    /**
     * Empty element
     *
     * Deleting content from element
     *
     * @param {Element} DOM Element
     *
     * @return {void}
     *
     * @function
     *
     * @since 1.0.0
     */
    static empty = function(ele) {
      while (ele.firstChild) {
        ele.removeChild(ele.firstChild);
      }
    };
    /**
     * Integer hash
     *
     * @param {string} str String to hash
     *
     * @return {number}
     *
     * @function
     *
     * @since 1.0.0
     */
    static hash = function(str) {
      let res = 0;
      const len = str.length;
      for (let i = 0; i < len; ++i) {
        res = res * 31 + str.charCodeAt(i);
      }
      return res;
    };
    /**
     * Check node
     *
     * Checking if a selection is a node
     *
     * @param {Node} DOM Node
     *
     * @return {boolean}
     *
     * @function
     *
     * @since 1.0.0
     */
    static isNode = function(ele) {
      return typeof Node === "object" ? ele instanceof Node : ele && typeof ele === "object" && typeof ele.nodeType === "number" && typeof ele.nodeName === "string";
    };
    /**
     * Check element
     *
     * Checking if a selection is a element
     *
     * @param {HTMLElement} DOM Element
     *
     * @return {boolean}
     *
     * @function
     *
     * @since 1.0.0
     */
    static isElement = function(o) {
      return typeof HTMLElement === "object" ? o instanceof HTMLElement : o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
    };
    /**
     * Getting element by class
     *
     * Getting a element by class in the first level
     *
     * @param {Element} DOM Element
     * @param {string}  Class to find
     *
     * @return {null|Element}
     *
     * @function
     *
     * @since 1.0.0
     */
    static getByClass = function(ele, cls) {
      const length = ele.childNodes.length;
      for (let i = 0; i < length; ++i) {
        if (_jsOMS.hasClass(ele.childNodes[i], cls)) {
          return ele.childNodes[i];
        }
      }
      return null;
    };
    /**
     * Adding event listener to multiple elements
     *
     * @param {Element}  e        DOM Elements
     * @param {string}   event    Event name
     * @param {function} callback Event callback
     *
     * @return {void}
     *
     * @function
     *
     * @since 1.0.0
     */
    static addEventListenerToAll = function(e, event, callback) {
      const length = e.length;
      for (let i = 0; i < length; ++i) {
        e[i].addEventListener(event, callback);
      }
    };
    /**
     * Validate json string
     *
     * @param {string} jsonString String to validate
     *
     * @return {boolean}
     *
     * @function
     *
     * @since 1.0.0
     */
    static isValidJson = function(jsonString) {
      try {
        JSON.parse(jsonString);
      } catch (e) {
        return false;
      }
      return true;
    };
    /**
     * Merging two arrays recursively
     *
     * @param {Object} target Target object
     * @param {Object} source Source object
     *
     * @return {Object}
     *
     * @function
     *
     * @since 1.0.0
     */
    static merge = function(target, source) {
      const out = _jsOMS.clone(target);
      for (const p in source) {
        if (Object.prototype.hasOwnProperty.call(source, p)) {
          if (typeof source[p] === "object") {
            out[p] = _jsOMS.merge(out[p], source[p]);
          } else {
            out[p] = source[p];
          }
        } else {
          out[p] = source[p];
        }
      }
      return out;
    };
    /**
     * Shallow clones an object.
     *
     * @param {Object} obj Object to clone
     *
     * @returns {Object}
     *
     * @since 1.0.0
     */
    static clone = function(obj) {
      return { ...obj };
    };
    /**
     * Is variable set
     *
     * @param {any} variable Variable
     *
     * @returns {boolean}
     *
     * @since 1.0.0
     */
    static isset = function(variable) {
      return typeof variable !== "undefined" && variable !== null;
    };
    /**
     * Get the remaining string after finding a certain char
     *
     * @param {string} haystack String to to search in
     * @param {Array}  chars    Chars to search for
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static strpbrk = function(haystack, chars) {
      const length = chars.length;
      let found = haystack.length;
      let min = haystack.length;
      for (let i = 0; i < length; ++i) {
        if ((found = haystack.indexOf(chars.charAt(i))) >= 0 && min > found) {
          min = found;
        }
      }
      return haystack.slice(min);
    };
  };

  // jsOMS/Asset/AssetManager.js
  var AssetManager = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.assets = {};
      this.registerLoadedAssets();
    }
    /**
     * Register all loaded assets.
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    registerLoadedAssets() {
      const scripts = document.getElementsByTagName("script");
      const length = !scripts ? 0 : scripts.length;
      this.assets = {};
      for (let i = 0; i < length; ++i) {
        this.assets[jsOMS2.hash(scripts[i].src)] = scripts[i].src;
      }
    }
    /**
     * Load asset.
     *
     * @param {string}   path     Asset path
     * @param {string}   filetype Filetype of the asset
     * @param {function} callback Callback after load
     *
     * @return {boolean|number}
     *
     * @since 1.0.0
     */
    load(path, filetype, callback) {
      let hash;
      if (!this.assets[hash = jsOMS2.hash(path)]) {
        let fileref = null;
        if (filetype === "js") {
          fileref = document.createElement("script");
          fileref.setAttribute("type", "text/javascript");
          fileref.setAttribute("src", path);
          if (typeof fileref !== "undefined") {
            const head = document.getElementsByTagName("head");
            if (head) {
              head[0].appendChild(fileref);
            }
          }
          this.assets[hash] = path;
        } else if (filetype === "css") {
          fileref = document.createElement("link");
          fileref.setAttribute("rel", "stylesheet");
          fileref.setAttribute("type", "text/css");
          fileref.setAttribute("href", path);
          if (typeof fileref !== "undefined") {
            const head = document.getElementsByTagName("head");
            if (head) {
              head[0].appendChild(fileref);
            }
          }
          this.assets[hash] = path;
        } else if (filetype === "img") {
          this.assets[hash] = new Image();
          this.assets[hash].src = path;
        }
        if (callback) {
          fileref.onreadystatechange = function() {
            if (this.readyState === "complete") {
              callback();
            }
          };
          fileref.onload = callback();
        }
        return hash;
      }
      return false;
    }
    /**
     * Get asset.
     *
     * @param {string} key Key of the asset
     *
     * @return {null|number}
     *
     * @since 1.0.0
     */
    get(key) {
      key = jsOMS2.hash(key);
      if (this.assets[key]) {
        return this.assets[key];
      }
      return null;
    }
    /**
     * Remove asset.
     *
     * @param {string} key Key of the asset
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    remove(key) {
      key = jsOMS2.hash(key);
      if (typeof this.assets[key] !== "undefined") {
        delete this.assets[key];
        return true;
      }
      return false;
    }
  };

  // jsOMS/Log/LogLevel.js
  var LogLevel = Object.freeze({
    EMERGENCY: "emergency",
    ALERT: "alert",
    CRITICAL: "critical",
    ERROR: "error",
    WARNING: "warning",
    NOTICE: "notice",
    INFO: "info",
    DEBUG: "debug"
  });

  // jsOMS/Uri/HttpUri.js
  var HttpUri = class _HttpUri {
    /**
     * @constructor
     *
     * @param {string} uri Http uri
     *
     * @since 1.0.0
     */
    constructor(uri) {
      this.uri = "";
      this.scheme = "";
      this.host = "";
      this.port = "";
      this.user = "";
      this.pass = "";
      this.query = null;
      this.queryString = "";
      this.fragment = "";
      this.base = "";
      this.root = "/";
      this.set(uri);
    }
    /**
     * Parse uri
     *
     * @param {string} str    Url to parse
     * @param {string} [mode] Parsing mode
     *
     * @return {Object}
     *
     * @throws {Error}
     *
     * @todo The default parser fails for uris which have a query without a value but a fragment e.g. ?debug#something.
     *          In such a case something#something is returned as fragment instead of just #something or something
     *
     * @since 1.0.0
     */
    static parseUrl(str, mode = "php") {
      const key = [
        "source",
        "scheme",
        "authority",
        "userInfo",
        "user",
        "pass",
        "host",
        "port",
        "relative",
        "path",
        "directory",
        "file",
        "query",
        "fragment"
      ];
      const parser = {
        php: /^(?:([^:\/?#]+):)?(?:\/\/()(?:(?:()(?:([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?()(?:(()(?:(?:[^?#\/]*\/)*)()(?:[^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/\/?)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
      };
      if (!Object.prototype.hasOwnProperty.call(parser, mode)) {
        throw new Error("Unexpected parsing mode.", "UriFactory", 52);
      }
      const m = parser[mode].exec(str);
      const uri = {};
      let i = 14;
      while (--i) {
        if (m[i]) {
          uri[key[i]] = m[i];
        }
      }
      delete uri.source;
      return uri;
    }
    /**
     * Get Uri query parameters.
     *
     * @param {string} query Uri query
     * @param {string} name  Name of the query to return
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static getUriQueryParameter(query, name) {
      name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
      const regex = new RegExp("[\\?&]*" + name + "=([^&#]*)");
      const results = regex.exec(query);
      return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
    }
    /**
     * Get all uri query parameters.
     *
     * @param {string} query Uri query
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    static getAllUriQueryParameters(query) {
      const params = {};
      let keyValPairs = [];
      let pairNum = null;
      if (query.length) {
        keyValPairs = query.split("&");
        for (pairNum in keyValPairs) {
          if (!Object.prototype.hasOwnProperty.call(keyValPairs, pairNum)) {
            continue;
          }
          const key = keyValPairs[pairNum].split("=")[0];
          if (!key.length) {
            continue;
          }
          if (typeof params[key] === "undefined") {
            params[key] = [];
          }
          params[key].push(keyValPairs[pairNum].split("=")[1]);
        }
      }
      return params;
    }
    /**
     * Set uri.
     *
     * @param {string} uri Uri string
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    set(uri) {
      this.uri = uri;
      const parsed = _HttpUri.parseUrl(this.uri, "php");
      this.scheme = parsed.scheme;
      this.host = parsed.host;
      this.port = parsed.port;
      this.user = parsed.user;
      this.pass = parsed.pass;
      this.path = parsed.path;
      if (this.path.endsWith(".php")) {
        this.path = this.path.substr(0, -4);
      }
      this.queryString = typeof parsed.query !== "undefined" ? parsed.query : [];
      if (this.queryString !== null) {
        this.query = _HttpUri.getAllUriQueryParameters(this.queryString);
      }
      this.fragment = typeof parsed.fragment !== "undefined" ? parsed.fragment : "";
      this.base = this.scheme + "://" + this.host + this.root;
    }
    /**
     * Set root path.
     *
     * @param {string} rootPath Uri root path
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setRootPath(rootPath) {
      this.root = rootPath;
      this.set(this.uri);
    }
    getRootPath() {
      return this.root;
    }
    /**
     * Get Uri base
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getBase() {
      return this.base;
    }
    /**
     * Get Uri scheme
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getScheme() {
      return this.scheme;
    }
    /**
     * Get Uri host
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getHost() {
      return this.host;
    }
    /**
     * Get Uri port
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getPort() {
      return this.port;
    }
    /**
     * Get Uri user
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getUser() {
      return this.user;
    }
    /**
     * Get Uri pass
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getPass() {
      return this.pass;
    }
    /**
     * Get Uri query
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getQuery() {
      return this.queryString;
    }
    /**
     * Get Uri
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getUri() {
      return this.uri;
    }
    /**
     * Get Uri fragment
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getFragment() {
      return this.fragment;
    }
    /**
     * Get Uri path
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getPath() {
      return this.path;
    }
    /**
     * Get Uri path offset
     *
     * @return {number}
     *
     * @since 1.0.0
     */
    getPathOffset() {
      return jsOMS2.substr_count(this.root, "/") - 1;
    }
  };

  // jsOMS/Message/Response/Response.js
  var Response = class {
    /**
     * @constructor
     *
     * @param {Object} data Response data
     *
     * @since 1.0.0
     */
    constructor(data) {
      this.responses = data;
    }
    /**
     * Get response by id.
     *
     * @param {null|string} [id] Response id
     *
     * @return {any}
     *
     * @since 1.0.0
     */
    get(id = null) {
      return id === null ? this.responses : typeof this.responses[id] === "undefined" ? null : this.responses[id];
    }
    /**
     * Count the amount of responses.
     *
     * @return {number}
     *
     * @since 1.0.0
     */
    count() {
      return this.responses.length;
    }
  };

  // jsOMS/Message/Request/RequestMethod.js
  var RequestMethod = Object.freeze({
    POST: "POST",
    GET: "GET",
    PUT: "PUT",
    DELETE: "DELETE",
    HEAD: "HEAD"
  });

  // jsOMS/Message/Response/ResponseType.js
  var ResponseType = Object.freeze({
    TEXT: "text",
    JSON: "json",
    DOCUMENT: "document",
    BLOB: "blob",
    ARRAYBUFFER: "arraybuffer",
    DEFAULT: ""
  });

  // jsOMS/UI/Component/Input.js
  var Input = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.visObs = null;
    }
    /**
     * Unbind input element
     *
     * @param {Element} input Input element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    static unbind(input) {
      this.app.inputManager.getKeyboardManager().unbind(input);
    }
    /**
     * Bind input element
     *
     * @param {Element} input Input element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    static bindElement(input = null) {
      if (input === null) {
        throw new Error("Input element required");
      }
      const type = input.type;
      const removeContentButton = input.parentNode.querySelector(".close");
      if (removeContentButton !== null && type !== "submit" && type !== "button") {
        removeContentButton.addEventListener("click", function() {
          input.value = "";
          input.focus();
        });
      }
    }
    /**
     * Add remote datalist options
     *
     * This only applies for datalists that have remote options
     *
     * @param {Element} input    Input element
     * @param {Element} datalist Datalist element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    static addRemoteDatalistOptions(input, datalist) {
      this.clearDatalistOptions(datalist);
      const request = new Request();
      request.setData(input.value);
      request.setType(ResponseType.JSON);
      request.setUri(datalist.getAttribute("data-list-src"));
      request.setMethod(RequestMethod.POST);
      request.setRequestHeader("Content-Type", "application/json");
      request.setSuccess(function(xhr) {
        try {
          const o = JSON.parse(xhr.response);
          const response = new Response(o);
          const responseLength = response.count();
          let tempResponse = null;
          for (let k = 0; k < responseLength; ++k) {
            tempResponse = response.getByIndex(k);
            let option = null;
            const data = tempResponse.getData();
            const length = data.length;
            for (let i = 0; i < length; ++i) {
              option = document.createElement("option");
              option.value = tempResponse.value;
              option.text = tempResponse.text;
              datalist.appendChild(option);
            }
          }
        } catch (exception) {
          Logger.instance.error("Invalid JSON object: " + xhr, "FormManager");
        }
      });
      request.send();
    }
    /**
     * Remove all datalist options from datalist
     *
     * @param {Element} datalist Datalist element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    static clearDatalistOptions(datalist) {
      const length = datalist.options.length;
      for (let i = 0; i < length; ++i) {
        datalist.remove(0);
      }
    }
  };

  // jsOMS/Views/FormView.js
  var FormView = class _FormView {
    /**
     * @constructor
     *
     * @param {string} id Form id
     *
     * @since 1.0.0
     */
    constructor(id) {
      this.id = id;
      this.success = null;
      this.finally = null;
      this.lastSubmit = 0;
      this.form = null;
      this.submitInjects = [];
      this.method = "POST";
      this.action = "";
      this.hasChanges = false;
      this.bind();
    }
    /**
     * Initialize members
     *
     * Pulled out since this is used in a cleanup process
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    initializeMembers() {
      this.submitInjects = [];
      this.method = "POST";
      this.action = "";
    }
    /**
     * Get method
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getMethod() {
      return this.method;
    }
    /**
     * Get action
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getAction() {
      return this.action;
    }
    /**
     * Get time of last submit
     *
     * @return {int}
     *
     * @since 1.0.0
     */
    getLastSubmit() {
      return this.lastSubmit;
    }
    /**
     * Update last submit time
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    updateLastSubmit() {
      this.lastSubmit = Math.floor(Date.now());
    }
    /**
     * Is form data submitted on change?
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    isOnChange() {
      const isOnChange = this.getFormElement().getAttribute("data-on-change");
      return isOnChange === "true" || isOnChange === "1";
    }
    /**
     * Get submit elements
     *
     * @param {null|Element} [e] Root element for search (null = whole document)
     *
     * @return {NodeListOf<any>}
     *
     * @since 1.0.0
     */
    getSubmit(e = null) {
      const parent = e === null ? document : e;
      return parent.querySelectorAll(
        "#" + this.id + " input[type=submit], button[form=" + this.id + "][type=submit], input[form=" + this.id + "][type=submit], #" + this.id + " button[type=submit], .submit[data-form=" + this.id + "], #" + this.id + " .submit" + (e !== null ? "  .submit" : "")
      );
    }
    /**
     * Get submit elements
     *
     * @return {NodeListOf<any>}
     *
     * @since 1.0.0
     */
    getImagePreviews() {
      return document.querySelectorAll(
        "#" + this.id + " input[type=file].preview"
      );
    }
    /**
     * Get edit elements
     *
     * @param {null|Element} [e] Root element for search (null = whole document)
     *
     * @return {NodeListOf<Element>}
     *
     * @since 1.0.0
     */
    getUpdate(e = null) {
      const parent = e === null ? document : e;
      return parent.querySelectorAll(
        "button[form=" + this.id + "].update-form, .update-form[data-form=" + this.id + "], #" + this.id + ' .update-form, [form="' + this.id + '"].update-form' + (e !== null ? ", .update-form" : "")
      );
    }
    /**
    * Get save elements
    *
    * @param {null|Element} [e] Root element for search (null = whole document)
    *
    * @return {NodeListOf<Element>}
    *
    * @since 1.0.0
    */
    getSave(e = null) {
      const parent = e === null ? document : e;
      return parent.querySelectorAll(
        "button[form=" + this.id + "].save-form, .save-form[data-form=" + this.id + "], #" + this.id + ' .save-form, [form="' + this.id + '"].save-form' + (e !== null ? ", .save-form" : "")
      );
    }
    /**
    * Get save elements
    *
    * @param {null|Element} [e] Root element for search (null = whole document)
    *
    * @return {NodeListOf<Element>}
    *
    * @since 1.0.0
    */
    getCancel(e = null) {
      const parent = e === null ? document : e;
      return parent.querySelectorAll(
        "#" + this.id + " input[type=reset], button[form=" + this.id + "][type=reset], input[form=" + this.id + "][type=reset], #" + this.id + " button[type=reset], button[form=" + this.id + "].cancel-form, .cancel-form[data-form=" + this.id + "], #" + this.id + ' .cancel-form, [form="' + this.id + '"].cancel-form' + (e !== null ? ", .cancel-form" : "")
      );
    }
    /**
     * Get remove buttons
     *
     * @param {null|Element} [e] Root element for search (null = whole document)
     *
     * @return {NodeListOf<Element>}
     *
     * @since 1.0.0
     */
    getRemove(e = null) {
      const parent = e === null ? document : e;
      return parent.querySelectorAll(
        "button[form=" + this.id + "].remove-form, .remove-form[data-form=" + this.id + "], #" + this.id + ' .remove-form, [form="' + this.id + '"].remove-form' + (e !== null ? ", .remove-form" : "")
      );
    }
    /**
     * Get add buttons
     *
     * The add button is different from the submit button since sometimes you want to show data to the user before you submit it.
     *
     * @param {null|Element} [e] Root element for search (null = whole document)
     *
     * @return {NodeListOf<Element>}
     *
     * @since 1.0.0
     */
    getAdd(e = null) {
      const parent = e === null ? document : e;
      return parent.querySelectorAll(
        "button[form=" + this.id + "].add-form, .add-form[data-form=" + this.id + "], #" + this.id + ' .add-form, [form="' + this.id + '"].add-form' + (e !== null ? ", .add-form" : "")
      );
    }
    /**
     * Get success callback
     *
     * @return {function}
     *
     * @since 1.0.0
     */
    getSuccess() {
      return this.success;
    }
    /**
     * Set success callback
     *
     * @param {function} callback Callback
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setSuccess(callback) {
      this.success = callback;
    }
    /**
     * Get finally callback
     *
     * @return {function}
     *
     * @since 1.0.0
     */
    getFinally() {
      return this.finally;
    }
    /**
     * Set finally callback
     *
     * @param {function} callback Callback
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setFinally(callback) {
      this.finally = callback;
    }
    /**
     * Inject submit with post callback
     *
     * @param {function} callback Callback
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    injectSubmit(callback) {
      this.submitInjects.push(callback);
    }
    /**
     * Get form elements
     *
     * @param {null|Object} [container] Data container, null = entire form or element e.g. table row
     *
     * @return {Element[]}
     *
     * @since 1.0.0
     */
    getFormElements(container = null) {
      const form = container === null ? this.getFormElement() : container;
      if (!form) {
        return [];
      }
      const selects = form.getElementsByTagName("select");
      const textareas = form.getElementsByTagName("textarea");
      const inputs = [].slice.call(form.getElementsByTagName("input"));
      const buttons = form.getElementsByTagName("button");
      const canvas = form.getElementsByTagName("canvas");
      const external = [].slice.call(document.querySelectorAll(":not(#" + this.id + ") [form=" + this.id + "]"));
      const special = form.querySelectorAll("[data-name]");
      const specialExt = document.querySelectorAll(":not(#" + this.id + ") [data-form=" + this.id + "]");
      const inputLength = inputs.length;
      const externalLength = external.length;
      const specialLength = specialExt.length;
      for (let i = 0; i < inputLength; ++i) {
        if (inputs[i] === void 0 || typeof inputs[i] !== "undefined" && (inputs[i].type === "checkbox" || inputs[i].type === "radio") && !inputs[i].checked) {
          delete inputs[i];
        }
      }
      for (let i = 0; i < externalLength; ++i) {
        if (external[i] === void 0 || typeof external[i] !== "undefined" && form.contains(external[i])) {
          delete external[i];
          continue;
        }
        if (external[i] === void 0 || typeof external[i] !== "undefined" && (external[i].type === "checkbox" || external[i].type === "radio") && !external[i].checked) {
          delete external[i];
        }
      }
      for (let i = 0; i < specialLength; ++i) {
        if (specialExt[i] === void 0 || typeof specialExt[i] !== "undefined" && form.contains(specialExt[i])) {
          delete specialExt[i];
          continue;
        }
      }
      return Array.prototype.slice.call(inputs).concat(
        Array.prototype.slice.call(selects),
        Array.prototype.slice.call(textareas),
        Array.prototype.slice.call(buttons),
        Array.prototype.slice.call(external),
        Array.prototype.slice.call(special),
        Array.prototype.slice.call(specialExt),
        Array.prototype.slice.call(canvas)
      ).filter(function(val) {
        return val;
      });
    }
    /**
     * Get first form element
     *
     * E.g. used to auto select first form element.
     *
     * @param {Element} e Root element for search (null = whole document)
     *
     * @return {Element}
     *
     * @since 1.0.0
     */
    getFirstInputElement(e = null) {
      const parent = e === null ? document : e;
      return parent.querySelector(
        "#" + this.id + " input, #" + this.id + " textarea, #" + this.id + " select, [form=" + this.id + "], [data-form=" + this.id + "]"
      );
    }
    /**
     * Get unique form elements
     *
     * @param {Array} arr Form element array
     *
     * @return {Array}
     *
     * @since 1.0.0
     */
    getUniqueFormElements(arr) {
      const seen = {};
      return arr.filter(function(item) {
        return Object.prototype.hasOwnProperty.call(seen, item.name) ? false : seen[item.name] = true;
      });
    }
    /**
     * Get form data
     *
     * @param {null|Element} Data container. Null = entire form, container e.g. single row in a table
     *
     * @return {FormData}
     *
     * @since 1.0.0
     */
    getData(container = null) {
      const data = {};
      const formData = new FormData();
      const elements = this.getFormElements(container);
      const length = elements.length;
      let value = null;
      for (let i = 0; i < length; ++i) {
        const id = _FormView.getElementId(elements[i]);
        if (id === null) {
          continue;
        }
        if (elements[i].tagName.toLowerCase() === "canvas") {
          value = elements[i].toDataURL("image/png");
        } else if (elements[i].tagName.toLowerCase() === "input" && elements[i].type === "file") {
          const filesLength = elements[i].files.length;
          for (let j = 0; j < filesLength; ++j) {
            formData.append(id + j, elements[i].files[j]);
          }
        } else if (elements[i].tagName.toLowerCase() === "iframe") {
          const iframeElements = Array.prototype.slice.call(
            elements[i].contentWindow.document.querySelectorAll("[form=" + this.id + "]")
          ).concat(
            Array.prototype.slice.call(
              elements[i].contentWindow.document.querySelectorAll("[data-form=" + this.id + "] [data-name]")
            )
          ).filter(function(val) {
            return val;
          });
          const iframeLength = iframeElements.length;
          for (let j = 0; j < iframeLength; ++j) {
            value = iframeElements[j].value;
            const iframeId = _FormView.getElementId(iframeElements[j]);
            if (Object.prototype.hasOwnProperty.call(data, iframeId)) {
              if (data[iframeId].constructor !== Array) {
                data[iframeId] = [data[iframeId]];
              }
              data[iframeId].push(value);
            } else {
              data[iframeId] = value;
            }
          }
          continue;
        } else if (typeof elements[i].value !== "undefined") {
          value = elements[i].value;
        } else if (elements[i].getAttribute("data-value") !== null) {
          value = elements[i].getAttribute("data-value");
        } else {
          value = elements[i].innerHTML;
        }
        if (Object.prototype.hasOwnProperty.call(data, id)) {
          if (data[id].constructor !== Array) {
            data[id] = [data[id]];
          }
          data[id].push(value);
        } else {
          data[id] = value;
        }
      }
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          formData.append(
            key,
            data[key] !== null && data[key].constructor === Array ? JSON.stringify(data[key]) : data[key]
          );
        }
      }
      return formData;
    }
    /**
     * Reset the form values to the default values
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    resetValues() {
      const elements = this.getFormElements();
      const length = elements.length;
      const form = this.getFormElement();
      form.reset();
      for (let i = 0; i < length; ++i) {
        const id = _FormView.getElementId(elements[i]);
        if (id === null) {
          continue;
        }
        if (elements[i].tagName.toLowerCase() === "canvas") {
          elements[i].clearRect(0, 0, elements[i].width, elements[i].height);
        } else if (elements[i].tagName.toLowerCase() === "textarea") {
          elements[i].innerHTML = "";
        }
        if (elements[i].getAttribute("data-value") !== null) {
          elements[i].setAttribute("data-value", "");
        }
        if (elements[i].getAttribute("data-name") !== null) {
          elements[i].innerHTML = "";
        }
      }
    }
    /**
     * Get form id
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getId() {
      return this.id;
    }
    /**
     * Get the form element
     *
     * @return {Element}
     *
     * @since 1.0.0
     */
    getFormElement() {
      return this.form === null ? this.form = document.getElementById(this.id) : this.form;
    }
    /**
     * Validate form
     *
     * @param {null|Element[]}
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    isValid(data = null) {
      const elements = data === null ? this.getFormElements() : data;
      const length = elements.length;
      try {
        for (let i = 0; i < length; ++i) {
          if (!elements[i].required && elements[i].value === "") {
            continue;
          } else if (elements[i].required && elements[i].value === "" || elements[i].required && elements[i].getAttribute("type") === "checkbox" && !elements[i].checked || typeof elements[i].pattern !== "undefined" && elements[i].pattern !== "" && !new RegExp(elements[i].pattern).test(elements[i].value) || typeof elements[i].maxlength !== "undefined" && elements[i].maxlength !== "" && elements[i].value.length > elements[i].maxlength || typeof elements[i].minlength !== "undefined" && elements[i].minlength !== "" && elements[i].value.length < elements[i].minlength || typeof elements[i].max !== "undefined" && elements[i].max !== "" && elements[i].value > elements[i].max || typeof elements[i].min !== "undefined" && elements[i].min !== "" && elements[i].value < elements[i].min) {
            return false;
          }
        }
      } catch (e) {
        jsOMS2.Log.Logger.instance.error(e);
      }
      return true;
    }
    /**
     * Get invalid data
     *
     * @param {null|Element[]}
     *
     * @return {Element[]}
     *
     * @since 1.0.0
     */
    getInvalid(data = null) {
      const elements = data === null ? this.getFormElements() : data;
      const length = elements.length;
      const invalid = [];
      try {
        for (let i = 0; i < length; ++i) {
          if (elements[i].required && elements[i].value === "" || typeof elements[i].pattern !== "undefined" && elements[i].pattern !== "" && !new RegExp(elements[i].pattern).test(elements[i].value) || typeof elements[i].maxlength !== "undefined" && elements[i].maxlength !== "" && elements[i].value.length > elements[i].maxlength || typeof elements[i].minlength !== "undefined" && elements[i].minlength !== "" && elements[i].value.length < elements[i].minlength || typeof elements[i].max !== "undefined" && elements[i].max !== "" && elements[i].value > elements[i].max || typeof elements[i].min !== "undefined" && elements[i].min !== "" && elements[i].value < elements[i].min) {
            invalid.push(elements[i]);
          }
        }
      } catch (e) {
        jsOMS2.Log.Logger.instance.error(e);
      }
      return invalid;
    }
    /**
     * Get form element id
     *
     * @param {Element} e Element to get id from
     *
     * @return {null|string}
     *
     * @since 1.0.0
     */
    static getElementId(e) {
      if (e.getAttribute("name") !== null) {
        return e.getAttribute("name");
      } else if (e.getAttribute("data-name") !== null) {
        return e.getAttribute("data-name");
      } else if (e.getAttribute("id") !== null) {
        return e.getAttribute("id");
      } else if (e.getAttribute("type") !== null) {
        return e.getAttribute("type");
      }
      return null;
    }
    /**
     * Get submit injects
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getSubmitInjects() {
      return this.submitInjects;
    }
    /**
     * Bind form
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind() {
      this.clean();
      this.form = this.getFormElement();
      if (this.form === null) {
        return;
      }
      if (typeof this.form.attributes.method !== "undefined") {
        this.method = this.form.attributes.method.value;
      } else if (typeof this.form.attributes["data-method"] !== "undefined") {
        this.method = this.form.attributes["data-method"].value;
      } else {
        this.method = "EMPTY";
      }
      if (typeof this.form.attributes.action !== "undefined") {
        this.action = this.form.attributes.action.value;
      } else if (typeof this.form.attributes["data-uri"] !== "undefined") {
        this.action = this.form.attributes["data-uri"].value;
      } else {
        this.action = "EMPTY";
      }
      const elements = this.getFormElements();
      const length = elements.length;
      for (let i = 0; i < length; ++i) {
        switch (elements[i].tagName.toLowerCase()) {
          case "input":
            Input.bindElement(elements[i]);
            break;
          case "select":
            break;
          case "textarea":
            break;
          case "button":
            break;
          default:
        }
      }
    }
    getElementsToBind(e = null) {
      const parent = e === null ? document : e;
      const externalElements = parent.querySelectorAll("[form=" + this.id + "]");
      return Array.prototype.slice.call(externalElements).concat(
        Array.prototype.slice.call([this.form])
      ).filter(function(val) {
        return val;
      });
    }
    /**
     * Clean form
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    clean() {
      this.initializeMembers();
    }
  };

  // jsOMS/Uri/UriFactory.js
  var UriFactory = class _UriFactory {
    /**
     * Set uri query
     *
     * @param {string}  key         Query key
     * @param {string}  value       Query value
     * @param {boolean} [overwrite] Overwrite if already exists?
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    static setQuery(key, value, overwrite = true) {
      if (overwrite || !Object.prototype.hasOwnProperty.call(_UriFactory.uri, key)) {
        _UriFactory.uri[key] = value;
        return true;
      }
      return false;
    }
    /**
     * Get query
     *
     * @param {string} key
     *
     * @return {null|string}
     *
     * @since 1.0.0
     */
    static getQuery(key) {
      return Object.prototype.hasOwnProperty.call(_UriFactory.uri, key) ? _UriFactory.uri[key] : null;
    }
    /**
     * Clear all uri components
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    static clearAll() {
      _UriFactory.uri = {};
      return true;
    }
    /**
     * Clear uri component
     *
     * @param {string} key Uri key for component
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    static clear(key) {
      if (Object.prototype.hasOwnProperty.call(_UriFactory.uri, key)) {
        delete _UriFactory.uri[key];
        return true;
      }
      return false;
    }
    /**
     * Clear uri components that follow a certain pattern
     *
     * @param {string} pattern Uri key pattern to remove
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    static clearLike(pattern) {
      let success = false;
      const regexp = new RegExp(pattern);
      for (const key in _UriFactory.uri) {
        if (Object.prototype.hasOwnProperty.call(_UriFactory.uri, key) && regexp.test(key)) {
          delete _UriFactory.uri[key];
          success = true;
        }
      }
      return success;
    }
    /**
     * Remove multiple definitions of the same parameter
     *
     * The parameters will be recognized from right to left since it's easier to push at the end.
     *
     * @param {string} url Url
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static unique(url) {
      const parsed = HttpUri.parseUrl(url);
      const pars = [];
      if (url.includes("?")) {
        const parts = typeof parsed.query === "undefined" ? [] : parsed.query.replace(/\?/g, "&").split("&");
        const comps = {};
        const length = parts.length;
        let spl = null;
        if ((typeof parsed.fragment === "undefined" || parsed.fragment === null) && parts[length - 1].includes("#")) {
          const lastQuery = parts[length - 1].split("#")[1];
          parsed.fragment = lastQuery[1];
          parts[length - 1] = lastQuery[0];
        }
        for (let i = 0; i < length; ++i) {
          spl = parts[i].split("=");
          comps[spl[0]] = spl.length < 2 ? "" : spl[1];
        }
        for (const a in comps) {
          if (Object.prototype.hasOwnProperty.call(comps, a) && comps[a] !== "" && comps[a] !== null && typeof comps[a] !== "undefined") {
            pars.push(a + "=" + (comps[a].includes("%") ? comps[a] : encodeURIComponent(comps[a])));
          } else if (Object.prototype.hasOwnProperty.call(comps, a)) {
            pars.push(a);
          }
        }
      }
      const fragments = typeof parsed.fragment !== "undefined" ? parsed.fragment.split("#") : null;
      url = (typeof parsed.scheme !== "undefined" ? parsed.scheme + "://" : "") + (typeof parsed.username !== "undefined" ? parsed.username + ":" : "") + (typeof parsed.password !== "undefined" ? parsed.password + "@" : "") + (typeof parsed.host !== "undefined" ? parsed.host : "") + (typeof parsed.port !== "undefined" ? ":" + parsed.port : "") + (typeof parsed.path !== "undefined" ? parsed.path : "") + (typeof parsed.query !== "undefined" ? "?" + pars.join("&") : "") + (typeof parsed.fragment !== "undefined" ? "#" + fragments[fragments.length - 1] : "");
      return url;
    }
    static buildAbsolute(uri, toMatch = null) {
      if (uri.startsWith("/")) {
        return _UriFactory.build(window.location.origin + uri, toMatch);
      } else if (uri.indexOf("://") === -1) {
        return _UriFactory.build(window.location.origin + "/" + uri, toMatch);
      }
      return uri;
    }
    /**
     * Build uri
     *
     * # = DOM id
     * . = DOM class
     * / = Current path
     * ? = Current query
     * @ = Name attribute
     * $ =
     * % = Current url
     * ! = Query selector
     *
     * @param {string}      uri       Raw uri
     * @param {null|Object} [toMatch] Key/value pair to replace in raw
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static build(uri, toMatch = null) {
      const current = HttpUri.parseUrl(window.location.href);
      const query = HttpUri.getAllUriQueryParameters(typeof current.query === "undefined" ? {} : current.query);
      for (const key in query) {
        if (Object.prototype.hasOwnProperty.call(query, key)) {
          _UriFactory.setQuery("?" + key, query[key]);
        }
      }
      let parsed = uri.replace(new RegExp("{[/#?%@.$!].*?}", "g"), function(match) {
        match = match.substring(1, match.length - 1);
        if (toMatch !== null && Object.prototype.hasOwnProperty.call(toMatch, match)) {
          return toMatch[match];
        } else if (typeof _UriFactory.uri[match] !== "undefined") {
          return _UriFactory.uri[match];
        } else if (match.indexOf("!") === 0) {
          const e = document.querySelector(match.substring(1));
          if (!e) {
            return "";
          }
          if (e.tagName.toLowerCase() !== "form") {
            return e.value;
          }
          let value = "";
          const form = new FormView(e.id).getData();
          for (const pair of form.entries()) {
            value += "&" + pair[0] + "=" + pair[1];
          }
          return value;
        } else if (match.indexOf("?") === 0) {
          return HttpUri.getUriQueryParameter(current.query, match.substring(1));
        } else if (match === "#") {
          return current.fragment;
        } else if (match.indexOf("#") === 0) {
          const e = document.getElementById(match.substring(1));
          if (e) {
            if (e.tagName.toLowerCase() !== "form") {
              return e.value;
            }
            let value = "";
            const form = new FormView(e.id).getData();
            for (const pair of form.entries()) {
              value += "&" + pair[0] + "=" + pair[1];
            }
            return value;
          }
          return "";
        } else if (match.indexOf("?") === 0) {
          return current.query();
        } else if (match.indexOf("/") === 0) {
          return current.path;
        } else if (match.indexOf(":user") === 0) {
          return current.user;
        } else if (match.indexOf(":pass") === 0) {
          return current.pass;
        } else if (match.indexOf("/") === 0) {
          return "ERROR PATH";
        } else if (match === "%") {
          return window.location.href;
        } else {
          return match;
        }
      });
      if (parsed.indexOf("?") === -1) {
        parsed = parsed.replace("&", "?");
      }
      return _UriFactory.unique(parsed);
    }
    /**
     * Set uri builder components.
     *
     * @param {HttpUri} uri Uri
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    static setupUriBuilder(uri) {
      _UriFactory.setQuery("/scheme", uri.getScheme());
      _UriFactory.setQuery("/host", uri.getHost());
      _UriFactory.setQuery("/base", jsOMS2.rtrim(uri.getBase(), "/"));
    }
  };
  UriFactory.uri = {};

  // jsOMS/Message/Request/RequestType.js
  var RequestType = Object.freeze({
    JSON: "json",
    RAW: "raw",
    FILE: "file",
    URL_ENCODE: "url",
    FORM_DATA: "formdata"
  });

  // jsOMS/Message/Request/Request.js
  var Request = class {
    /**
     * @constructor
     *
     * @param {null|string} [uri]    Request uri
     * @param {null|string} [method] Request method/verb
     * @param {null|string} [type]   Request content type
     *
     * @since 1.0.0
     */
    constructor(uri = null, method = null, type = null) {
      this.uri = uri;
      this.method = method !== null ? method : RequestMethod.GET;
      this.requestHeader = {};
      this.result = {};
      this.type = type !== null ? type : RequestType.JSON;
      this.data = {};
      this.requestHeader["Content-Type"] = this.setContentTypeBasedOnType(this.type);
      if (this.type === RequestType.FORM_DATA) {
        delete this.requestHeader["Content-Type"];
      }
      this.result[0] = function(xhr) {
        Logger2.getInstance().info('Unhandled response from "' + xhr.responseURL + '" with response data "' + xhr.response + '"');
      };
      this.xhr = new XMLHttpRequest();
    }
    /**
     * Defines the request content type based on the type
     *
     * @param {string} type Request type
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    setContentTypeBasedOnType(type) {
      switch (type) {
        case RequestType.JSON:
          return "application/json";
        case RequestType.URL_ENCODE:
          return "application/x-www-form-urlencoded";
        case RequestType.FILE:
          return "";
        case RequestType.FORM_DATA:
          return "multipart/form-data";
        default:
          return "*/*";
      }
    }
    /**
     * Set request method.
     *
     * @param {string} method Method type
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setMethod(method) {
      this.method = method;
    }
    /**
     * Get request method.
     *
     * EnumRequestMethod
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getMethod() {
      return this.method;
    }
    /**
     * Set response type.
     *
     * @param {string} type Method type
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setResponseType(type) {
      this.xhr.responseType = type;
    }
    /**
     * Get response type.
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getResponseType() {
      return this.responseType;
    }
    /**
     * Set request header.
     *
     * @param {string} type   Request type
     * @param {string} header Request header
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setRequestHeader(type, header) {
      this.requestHeader[type] = header;
      if (header === "multipart/form-data") {
        delete this.requestHeader[type];
      }
    }
    /**
     * Get request header.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getRequestHeader() {
      return this.requestHeader;
    }
    /**
     * Set request uri.
     *
     * @param {string} uri Request uri
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setUri(uri) {
      this.uri = uri;
    }
    /**
     * Get request uri.
     *
     * @return {null|string}
     *
     * @since 1.0.0
     */
    getUri() {
      return this.uri;
    }
    /**
     * Set success callback.
     *
     * @param {function} callback - Success callback
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setSuccess(callback) {
      this.result[200] = callback;
    }
    /**
     * Set result callback.
     *
     * @param {number}   status   Http response status
     * @param {function} callback Callback
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setResultCallback(status, callback) {
      this.result[status] = callback;
    }
    /**
     * Set request data.
     *
     * @param {Object} data Request data
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setData(data) {
      this.data = data;
    }
    /**
     * Get request data.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getData() {
      return this.data;
    }
    /**
     * Set request type.
     *
     * @param {string} type Method type
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setType(type) {
      this.type = type;
      this.requestHeader["Content-Type"] = this.setContentTypeBasedOnType(this.type);
    }
    /**
     * Get request type.
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getType() {
      return this.type;
    }
    /**
     * Create query from object.
     *
     * @param {Object} obj Object to turn into uri query
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    queryfy(obj) {
      const str = [];
      for (const p in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, p)) {
          str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
        }
      }
      return str.join("&");
    }
    /**
     * Send request.
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    send() {
      if (this.uri === "") {
        return;
      }
      const self2 = this;
      if (this.xhr.readyState !== 1) {
        if (this.type === RequestType.FORM_DATA) {
          if (this.method === RequestMethod.GET) {
            let url = this.uri;
            for (const pair of this.data.entries()) {
              url += "&" + pair[0] + "=" + pair[1];
            }
            this.xhr.open(this.method, UriFactory.build(url));
          } else {
            this.xhr.open(this.method, UriFactory.build(this.uri));
          }
        } else {
          console.log(UriFactory.build(this.uri));
          this.xhr.open(this.method, UriFactory.build(this.uri));
        }
        for (const p in this.requestHeader) {
          if (Object.prototype.hasOwnProperty.call(this.requestHeader, p) && this.requestHeader[p] !== "") {
            if (this.requestHeader[p] !== "multipart/form-data") {
              this.xhr.setRequestHeader(p, this.requestHeader[p]);
            }
          }
        }
      }
      window.omsApp.logger.log(UriFactory.build(this.uri));
      window.omsApp.logger.log(this.xhr);
      this.xhr.onreadystatechange = function() {
        switch (self2.xhr.readyState) {
          case 4:
            if (typeof self2.result[self2.xhr.status] === "undefined") {
              self2.result[0](self2.xhr);
            } else {
              self2.result[self2.xhr.status](self2.xhr);
            }
            break;
          default:
        }
      };
      if (this.type === RequestType.JSON) {
        this.xhr.send(JSON.stringify(this.data));
      } else if (this.type === RequestType.RAW || this.type === RequestType.FILE) {
        this.xhr.send(this.data);
      } else if (this.type === RequestType.URL_ENCODE) {
        this.xhr.send(this.queryfy(this.data));
      } else if (this.type === RequestType.FORM_DATA) {
        this.xhr.send(this.data);
      }
    }
  };

  // jsOMS/System/BrowserType.js
  var BrowserType = Object.freeze({
    OPERA: "opera",
    FIREFOX: "firefox",
    SAFARI: "safari",
    IE: "msie",
    EDGE: "edge",
    CHROME: "chrome",
    BLINK: "blink",
    UNKNOWN: "unknown"
  });

  // jsOMS/System/OSType.js
  var OSType = Object.freeze({
    WINDOWS_10: "windows nt 10.0",
    /* Windows 10 */
    WINDOWS_81: "windows nt 6.3",
    /* Windows 8.1 */
    WINDOWS_8: "windows nt 6.2",
    /* Windows 8 */
    WINDOWS_7: "windows nt 6.1",
    /* Windows 7 */
    WINDOWS_VISTA: "windows nt 6.0",
    /* Windows Vista */
    WINDOWS_SERVER: "windows nt 5.2",
    /* Windows Server 2003/XP x64 */
    WINDOWS_XP: "windows nt 5.1",
    /* Windows XP */
    WINDOWS_XP_2: "windows xp",
    /* Windows XP */
    WINDOWS_2000: "windows nt 5.0",
    /* Windows 2000 */
    WINDOWS_ME: "windows me",
    /* Windows ME */
    WINDOWS_98: "win98",
    /* Windows 98 */
    WINDOWS_95: "win95",
    /* Windows 95 */
    WINDOWS_311: "win16",
    /* Windows 3.11 */
    MAC_OS_X: "macintosh",
    /* Mac OS X */
    MAC_OS_X_2: "mac os x",
    /* Mac OS X */
    MAC_OS_9: "mac_powerpc",
    /* Mac OS 9 */
    LINUX: "linux",
    /* Linux */
    UBUNTU: "ubuntu",
    /* Ubuntu */
    IPHONE: "iphone",
    /* IPhone */
    IPOD: "ipod",
    /* IPod */
    IPAD: "ipad",
    /* IPad */
    ANDROID: "android",
    /* Android */
    BLACKBERRY: "blackberry",
    /* Blackberry */
    MOBILE: "webos",
    /* Mobile */
    UNKNOWN: "UNKNOWN"
    /* Unknown */
  });

  // jsOMS/System/SystemUtils.js
  var SystemUtils = class {
    /**
     * Get browser.
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static getBrowser() {
      if (!!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0) {
        return BrowserType.OPERA;
      } else if (typeof InstallTrigger !== "undefined") {
        return BrowserType.FIREFOX;
      } else if (Object.toString.call(window.HTMLElement).indexOf("Constructor") > 0) {
        return BrowserType.SAFARI;
      } else if (!!document.documentMode) {
        return BrowserType.IE;
      } else if (!!window.StyleMedia) {
        return BrowserType.EDGE;
      } else if (!!window.chrome && !!window.chrome.webstore) {
        return BrowserType.CHROME;
      } else if ((typeof isChrome !== "undefined" && isChrome || typeof isOpera !== "undefined" && isOpera) && !!window.CSS) {
        return BrowserType.BLINK;
      }
      return BrowserType.UNKNOWN;
    }
    /**
     * Get os.
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static getOS() {
      for (const os in OSType) {
        if (Object.prototype.hasOwnProperty.call(OSType, os)) {
          if (navigator.appVersion.toLowerCase().indexOf(OSType[os]) !== -1) {
            return OSType[os];
          }
        }
      }
      return OSType.UNKNOWN;
    }
  };

  // jsOMS/Log/Logger.js
  var Logger2 = class _Logger {
    /**
     * @constructor
     *
     * @param {boolean} [verbose] Verbose logging
     * @param {boolean} [ui]      Ui logging
     * @param {boolean} [remote]  Remote logging
     *
     * @since 1.0.0
     */
    constructor(verbose = true, ui = true, remote = false) {
      this.verbose = verbose;
      this.ui = ui;
      this.remote = remote;
    }
    /**
     * Get logging instance
     *
     * @param {boolean} [verbose] Verbose logging
     * @param {boolean} [ui]      Ui logging
     * @param {boolean} [remote]  Remote logging
     *
     * @return {Logger}
     *
     * @since 1.0.0
     */
    static getInstance(verbose = true, ui = true, remote = false) {
      if (!_Logger.instance) {
        _Logger.instance = new _Logger(verbose, ui, remote);
      }
      return _Logger.instance;
    }
    /**
     * Interpolate message
     *
     * @param {string} message   Message structure
     * @param {Object} [context] Context to put into message
     * @param {string} [level]   Log level
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    interpolate(message, context) {
      message = typeof message === "undefined" ? _Logger.MSG_FULL : message;
      for (const replace in context) {
        if (Object.prototype.hasOwnProperty.call(context, replace) && typeof message === "string") {
          message = message.replace("{" + replace + "}", context[replace]);
        }
      }
      return typeof message !== "string" ? JSON.stringify(message) : message;
    }
    /**
     * Create context
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     * @param {string} level     Log level
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    createContext(message, context, level) {
      context.backtrace = console.trace();
      context.datetime = (/* @__PURE__ */ new Date()).toISOString();
      context.version = "1.0.0";
      context.os = SystemUtils.getOS();
      context.browser = SystemUtils.getBrowser();
      context.path = window.location.href;
      context.datetime = (/* @__PURE__ */ new Date()).toString();
      context.level = level;
      context.message = message;
      return context;
    }
    /**
     * Create log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     * @param {string} level     Log level
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    write(message, context, level) {
      context = this.createContext(message, context, level);
      if (this.verbose) {
        this.writeVerbose(message, context, level);
      }
      if (this.ui) {
        this.writeUi(message, context);
      }
      if (this.remote) {
        this.writeRemote(context);
      }
    }
    /**
     * Create ui log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    writeUi(message, context) {
      if (Notification.permission !== "granted" && Notification.permission !== "denied") {
        Notification.requestPermission().then(function(permission) {
        });
      }
      const notification = new Notification("Logger", { body: this.interpolate(message, context) });
      setTimeout(notification.close.bind(notification), 4e3);
    }
    /**
     * Create local log message in console
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     * @param {string} level     Log level
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    writeVerbose(message, context, level) {
      let color = "000";
      switch (level) {
        case "info":
        case "notice":
        case "log":
          color = "000";
          break;
        case "debug":
          color = "289E39";
          break;
        case "warning":
        case "alert":
          color = "FFA600";
          break;
        case "error":
        case "critical":
        case "emergency":
          color = "CF304A";
          break;
        default:
      }
      console.log("%c" + this.interpolate(message, context, level), "color: #" + color);
    }
    /**
     * Create remote log message
     *
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    writeRemote(context) {
      const request = new Request();
      request.setData(context);
      request.setType(jsOMS.Message.Response.Response.ResponseType.JSON);
      request.setUri("/{/lang}/api/log");
      request.setMethod(Request.RequestMethod.POST);
      request.setRequestHeader("Content-Type", "application/json");
      request.setSuccess(function(xhr) {
      });
      request.send();
    }
    /**
     * Create log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    emergency(message, context = {}) {
      this.write(message, context, LogLevel.EMERGENCY);
    }
    /**
     * Create log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    alert(message, context = {}) {
      this.write(message, context, LogLevel.ALERT);
    }
    /**
     * Create log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    critical(message, context = {}) {
      this.write(message, context, LogLevel.CRITICAL);
    }
    /**
     * Create log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    error(message, context = {}) {
      this.write(message, context, LogLevel.ERROR);
    }
    /**
     * Create log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    warning(message, context = {}) {
      this.write(message, context, LogLevel.WARNING);
    }
    /**
     * Create log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    notice(message, context = {}) {
      this.write(message, context, LogLevel.NOTICE);
    }
    /**
     * Create log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    info(message, context = {}) {
      this.write(message, context, LogLevel.INFO);
    }
    /**
     * Create log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    debug(message, context = {}) {
      this.write(message, context, LogLevel.DEBUG);
    }
    /**
     * Create log message
     *
     * @param {string} level     Log level
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    log(level, message, context = {}) {
      this.write(message, context, level);
    }
    /**
     * Create log message
     *
     * @param {string} message   Message to display
     * @param {Object} [context] Context to put into message
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    console(message, context = {}) {
      this.writeVerbose(message, context, LogLevel.INFO);
    }
  };
  Logger2.instance = null;
  Logger2.MSG_FULL = "{datetime}; {level}; {version}; {os}; {browser}; {path}; {message}";

  // jsOMS/DataStorage/CacheManager.js
  var CacheManager = class {
  };

  // jsOMS/DataStorage/StorageManager.js
  var StorageManager = class {
  };

  // jsOMS/Event/EventManager.js
  var EventManager = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.logger = Logger2.getInstance();
      this.groups = {};
      this.callbacks = {};
    }
    /**
     * Add event group (element)
     *
     * Adding the same event overwrites the existing one as "waiting"
     *
     * @param {string|number} group Group id
     * @param {string|number} id    Event id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    addGroup(group, id) {
      if (typeof this.groups[group] === "undefined") {
        this.groups[group] = {};
      }
      this.groups[group][id] = false;
    }
    /**
     * Resets the group status
     *
     * @param {string|number} group Group id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    reset(group) {
      for (const id in this.groups[group]) {
        if (Object.prototype.hasOwnProperty.call(this.groups[group], id)) {
          this.groups[group][id] = false;
        }
      }
    }
    /**
     * Does group have outstanding events
     *
     * @param {string|number} group Group id
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    hasOutstanding(group) {
      if (typeof this.groups[group] === "undefined") {
        return false;
      }
      for (const id in this.groups[group]) {
        if (!Object.prototype.hasOwnProperty.call(this.groups[group], id) || !this.groups[group][id]) {
          return true;
        }
      }
      return false;
    }
    /**
     * Trigger event based on regex for group and/or id
     *
     * @param {string|number} group  Group id (can be regex)
     * @param {string|number} [id]   Event id (can be regex)
     * @param {null|Object}   [data] Data for event
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    triggerSimilar(group, id = "", data = null) {
      const groupIsRegex = group.startsWith("/");
      const idIsRegex = id.startsWith("/");
      const groups = {};
      for (const groupName in this.groups) {
        const groupNameIsRegex = groupName.startsWith("/");
        if (groupIsRegex) {
          if (groupName.match(group)) {
            groups[groupName] = [];
          }
        } else if (groupNameIsRegex && group.match(groupName)) {
          groups[groupName] = [];
        } else if (groupName === group) {
          groups[groupName] = [];
        }
      }
      for (const groupName in groups) {
        for (const idName in this.groups[groupName]) {
          const idNameIsRegex = idName.startsWith("/");
          if (idIsRegex) {
            if (idName.match(id)) {
              groups[groupName].push(idName);
            }
          } else if (idNameIsRegex && id.match(idName)) {
            groups[groupName].push(id);
          } else if (idName === id) {
            groups[groupName].push([]);
          }
        }
        if (groups[groupName].length === 0) {
          groups[groupName].push(id);
        }
      }
      let triggerValue = false;
      for (const groupName in groups) {
        for (const id2 in groups[groupName]) {
          triggerValue = this.trigger(groupName, id2, data) || triggerValue;
        }
      }
      return triggerValue;
    }
    /**
     * Trigger event finished
     *
     * Executes the callback specified for this group if all events are finished
     *
     * @param {string|number} group  Group id
     * @param {string|number} [id]   Event id
     * @param {null|Object}   [data] Data for event
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    trigger(group, id = "", data = null) {
      if (typeof this.callbacks[group] === "undefined") {
        return false;
      }
      if (Math.abs(Date.now() - this.callbacks[group].lastRun) < 300) {
        return false;
      }
      if (typeof this.groups[group] !== "undefined") {
        this.groups[group][id] = true;
      }
      if (this.hasOutstanding(group)) {
        return false;
      }
      const length = this.callbacks[group].callbacks.length;
      this.callbacks[group].lastRun = Date.now();
      for (let i = 0; i < length; ++i) {
        this.callbacks[group].callbacks[i](data);
      }
      if (this.callbacks[group].remove) {
        this.detach(group);
      } else if (this.callbacks[group].reset) {
        this.reset(group);
      }
      return true;
    }
    /**
     * Detach event
     *
     * @param {string|number} group Group id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    detach(group) {
      return this.detachCallback(group) | this.detachGroup(group);
    }
    /**
     * Detach callback
     *
     * @param {string|number} group Group id
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    detachCallback(group) {
      if (Object.prototype.hasOwnProperty.call(this.callbacks, group)) {
        delete this.callbacks[group];
        return true;
      }
      return false;
    }
    /**
     * Detach group
     *
     * @param {string|number} group Group id
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    detachGroup(group) {
      if (Object.prototype.hasOwnProperty.call(this.groups, group)) {
        delete this.groups[group];
        return true;
      }
      return false;
    }
    /**
     * Attach callback to event group
     *
     * @param {string|number} group    Group id
     * @param {function}      callback Callback or route for the event
     * @param {boolean}       [remove] Should be removed after execution
     * @param {boolean}       [reset]  Reset after triggering
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    attach(group, callback, remove = false, reset = false) {
      if (!Object.prototype.hasOwnProperty.call(this.callbacks, group)) {
        this.callbacks[group] = { remove, reset, callbacks: [], lastRun: 0 };
      }
      this.callbacks[group].callbacks.push(callback);
      return true;
    }
    /**
     * Is a certain group already attached
     *
     * @param {string|number} group Group id
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    isAttached(group) {
      return Object.prototype.hasOwnProperty.call(this.callbacks, group);
    }
    /**
     * Count events
     *
     * @return {number}
     *
     * @since 1.0.0
     */
    count() {
      return Object.keys(this.callbacks).length;
    }
  };

  // jsOMS/Message/Response/ResponseManager.js
  var ResponseManager = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.messages = {};
    }
    /**
     * Add response handler.
     *
     * This allows the response handler to generally handle responses and also handle specific requests if defined.
     *
     * @param {string}      key       Response key
     * @param {function}    message   Callback for message
     * @param {null|string} [request] Request id in order to only handle a specific request
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    add(key, message, request = null) {
      request = typeof request !== "undefined" ? request : "any";
      if (typeof this.messages[key] === "undefined") {
        this.messages[key] = [];
      }
      this.messages[key][request] = message;
    }
    /**
     * Execute a predefined callback.
     *
     * Tries to execute a request specific callback or otherwise a general callback if defined.
     *
     * @param {string}       key       Response key
     * @param {Object}       data      Date to use in callback
     * @param {null|Request} [request] Request id for request specific execution
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    run(key, data, request = null) {
      if (request !== null && typeof this.messages[key] !== "undefined" && typeof this.messages[key][request] !== "undefined") {
        this.messages[key][request](data);
      } else if (typeof this.messages[key] !== "undefined") {
        this.messages[key].null(data);
      } else {
        jsOMS2.Log.Logger.instance.warning("Undefined type: " + key);
      }
    }
  };

  // jsOMS/Account/AccountManager.js
  var AccountManager = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.accounts = [];
    }
    /**
     * Add account.
     *
     * @param {Account} account Account
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    add(account) {
      this.accounts[account.getId()] = account;
    }
    /**
     * Remove account.
     *
     * @param {number} id Account id
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    remove(id) {
      if (typeof this.accounts[id] !== "undefined") {
        delete this.accounts[id];
        return true;
      }
      return false;
    }
    /**
     * Get account by id.
     *
     * @param {number} id Account id
     *
     * @return {null|Account}
     *
     * @since 1.0.0
     */
    get(id) {
      if (this.accounts[id]) {
        return this.accounts[id];
      }
      return null;
    }
  };

  // jsOMS/Message/Notification/NotificationLevel.js
  var NotificationLevel = Object.freeze({
    OK: "ok",
    INFO: "info",
    WARNING: "warning",
    ERROR: "error",
    HIDDEN: "hidden"
  });

  // jsOMS/Message/Notification/NotificationMessage.js
  var NotificationMessage = class {
    /**
     * @constructor
     *
     * @param {string}  status     Message status
     * @param {string}  title      Message title
     * @param {string}  message    Message content
     * @param {boolean} [vibrate]  Vibrate
     * @param {boolean} [isSticky] Should remain in the ui until manually removed
     *
     * @since 1.0.0
     */
    constructor(status, title, message, vibrate = false, isSticky = false) {
      this.status = status;
      this.title = title;
      this.message = message;
      this.vibrate = vibrate;
      this.isSticky = isSticky;
      this.primaryButton = null;
      this.secondaryButton = null;
      this.duration = 3e3;
    }
  };

  // jsOMS/Message/Notification/NotificationType.js
  var NotificationType = Object.freeze({
    APP_NOTIFICATION: 1,
    BROWSER_NOTIFICATION: 2
  });

  // jsOMS/UI/Component/AdvancedInput.js
  var AdvancedInput = class _AdvancedInput {
    /**
     * @constructor
     *
     * @param {Element}      e            Element to bind
     * @param {EventManager} eventManager Event manager
     * @param {Object}       observer     Observer
     *
     * @since 1.0.0
     */
    constructor(e, eventManager, observer) {
      this.id = e.id;
      this.inputComponent = e;
      this.inputField = this.inputComponent.getElementsByClassName("input")[0];
      this.dropdownElement = document.getElementById(this.id + "-popup");
      this.tagElement = document.getElementById(this.id + "-tags");
      this.dataList = this.dropdownElement.getElementsByTagName("table")[0];
      this.dataListBody = this.dataList.getElementsByTagName("tbody")[0];
      this.dataTpl = document.getElementById(this.id + "-rowElement");
      this.tagTpl = this.tagElement !== null ? this.tagElement.getElementsByTagName("template")[0] : null;
      this.src = this.inputField.getAttribute("data-src");
      const self2 = this;
      this.inputField.addEventListener("focusout", function(e2) {
        if (e2.relatedTarget === null || e2.relatedTarget.parentElement === null || e2.relatedTarget.parentElement.parentElement === null || !jsOMS2.hasClass(e2.relatedTarget.parentElement.parentElement.parentElement, "popup")) {
          jsOMS2.removeClass(self2.dropdownElement, "active");
        }
      });
      this.inputField.addEventListener("keydown", function(e2) {
        if (e2.keyCode === 13 || e2.keyCode === 40) {
          jsOMS2.preventAll(e2);
        }
        if (e2.keyCode === 40) {
          self2.selectOption(self2.dataListBody.firstElementChild);
          jsOMS2.preventAll(e2);
        } else {
          self2.inputTimeDelay({ id: self2.id, delay: 300 }, self2.changeCallback, self2, e2);
        }
      });
      this.inputField.addEventListener("focusin", function(e2) {
        jsOMS2.addClass(self2.dropdownElement, "active");
      });
      this.dropdownElement.addEventListener("keydown", function(e2) {
        jsOMS2.preventAll(e2);
        if (e2.code === "Escape" || e2.code === "Delete" || e2.code === "Backspace") {
          self2.inputField.focus();
          self2.clearDataListSelection(self2);
        } else if (e2.code === "ArrowUp") {
          if (document.activeElement.previousElementSibling !== null) {
            self2.clearDataListSelection(self2);
            self2.selectOption(document.activeElement.previousElementSibling);
          }
        } else if (e2.code === "ArrowDown") {
          if (document.activeElement.nextElementSibling !== null) {
            self2.clearDataListSelection(self2);
            self2.selectOption(document.activeElement.nextElementSibling);
          }
        } else if (e2.code === "Enter" || e2.code === "Tab") {
          self2.clearDataListSelection(self2);
          self2.addToResultList(self2, document.activeElement);
        }
      });
      this.dropdownElement.addEventListener("focusout", function(e2) {
        self2.clearDataListSelection(self2);
        jsOMS2.removeClass(self2.dropdownElement, "active");
      });
      this.dropdownElement.addEventListener("click", function(e2) {
        if (document.activeElement.tagName.toLowerCase() !== "tr") {
          return;
        }
        self2.clearDataListSelection(self2);
        self2.addToResultList(self2, document.activeElement);
        jsOMS2.removeClass(self2.dropdownElement, "active");
      });
      observer.observe(this.tagElement, { childList: true, attributes: false, subtree: false });
      eventManager.attach(this.id + "-tags-childList", function(data) {
        const removes = data.target.querySelectorAll(".close");
        const removesLength = removes === null ? 0 : removes.length;
        if (removesLength < 1) {
          return;
        }
        removes[removesLength - 1].addEventListener("click", function(e2) {
          if (e2.target.parentNode.parentNode === null) {
            return;
          }
          e2.target.parentNode.parentNode.removeChild(e2.target.parentNode);
        });
      });
    }
    /**
     * Handle remote data response result
     *
     * This method adds remote results to the dropdown list for selecting
     *
     * @param {AdvancedInput} self This reference
     * @param {Object}        data Response data
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    remoteCallback(self2, data) {
      window.omsApp.logger.log(data);
      data = JSON.parse(data.response)[0];
      const dataLength = data.length;
      if (self2.dropdownElement.getAttribute("data-active") === "true") {
        while (self2.dataListBody.firstChild) {
          self2.dataListBody.removeChild(self2.dataListBody.firstChild);
        }
        for (let i = 0; i < dataLength; ++i) {
          const newRow = self2.dataTpl.content.cloneNode(true);
          let fields = newRow.querySelectorAll("[data-tpl-text]");
          let fieldLength = fields.length;
          for (let j = 0; j < fieldLength; ++j) {
            fields[j].appendChild(
              document.createTextNode(
                jsOMS2.getArray(fields[j].getAttribute("data-tpl-text"), data[i])
              )
            );
          }
          fields = newRow.querySelectorAll("[data-tpl-value]");
          fieldLength = fields.length;
          for (let j = 0; j < fieldLength; ++j) {
            fields[j].setAttribute(
              "data-value",
              jsOMS2.getArray(fields[j].getAttribute("data-tpl-value"), data[i])
            );
          }
          newRow.firstElementChild.setAttribute("data-data", JSON.stringify(data[i]));
          self2.dataListBody.appendChild(newRow);
          self2.dataListBody.lastElementChild.addEventListener("focusout", function(e) {
            if (e.relatedTarget === null) {
              return;
            }
            let sibling = e.relatedTarget.parentNode.firstElementChild;
            do {
              if (sibling === e.relatedTarget) {
                jsOMS2.preventAll(e);
                return;
              }
            } while ((sibling = sibling.nextElementSibling) !== null);
          });
        }
      }
    }
    /**
     * Callback for input field content change
     *
     * @param {AdvancedInput} self This reference
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    changeCallback(self2) {
      if (typeof self2.src !== "undefined" && self2.src !== "") {
        const request = new Request(self2.src);
        request.setSuccess(function(data) {
          self2.remoteCallback(self2, data);
        });
        request.send();
      }
    }
    /**
     * Select element in dropdown (only mark it as selected)
     *
     * @param {Element} e Element to select in dropdown
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    selectOption(e) {
      e.focus();
      e.setAttribute("style", "background: #f00");
      jsOMS2.addClass(e, "active");
    }
    /**
     * Clear all selected/marked options in dropdown
     *
     * @param {AdvancedInput} self This reference
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    clearDataListSelection(self2) {
      const list = self2.dataListBody.getElementsByTagName("tr");
      const length = list.length;
      for (let i = 0; i < length; ++i) {
        list[i].setAttribute("style", "");
        jsOMS2.removeClass(list[i], "active");
      }
    }
    /**
     * Add selected dropdown elements to some final result list
     *
     * This can add the selected dropdown elements to a table, badge list etc. depending on the template structure.
     *
     * @param {AdvancedInput}  self This reference
     * @param {Element}        e    Element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    addToResultList(self2, e) {
      const data = JSON.parse(e.getAttribute("data-data"));
      if (self2.inputField.getAttribute("data-autocomplete") === "true") {
        self2.inputField.value = jsOMS2.getArray(self2.inputField.getAttribute("data-value"), data);
      }
      if (self2.tagElement !== null && self2.tagElement.getAttribute("data-active") === "true") {
        const newTag = self2.tagTpl.content.cloneNode(true);
        let fields = newTag.querySelectorAll("[data-tpl-value]");
        let fieldLength = fields.length;
        let uuid = "";
        let value = "";
        for (let j = 0; j < fieldLength; ++j) {
          fields[j].setAttribute(
            "data-value",
            jsOMS2.getArray(fields[j].getAttribute("data-tpl-value"), data)
          );
          value = jsOMS2.getArray(fields[j].getAttribute("data-tpl-value"), data);
          uuid += value;
        }
        if (self2.tagElement.querySelectorAll('[data-tpl-uuid="' + uuid + '"').length !== 0) {
          return;
        }
        newTag.firstElementChild.setAttribute("data-tpl-uuid", uuid);
        fields = newTag.querySelectorAll("[data-tpl-text]");
        fieldLength = fields.length;
        for (let j = 0; j < fieldLength; ++j) {
          fields[j].appendChild(
            document.createTextNode(
              jsOMS2.getArray(fields[j].getAttribute("data-tpl-text"), data)
            )
          );
        }
        const regex = /{\/.*?}/g;
        const matches = newTag.firstElementChild.outerHTML.match(regex);
        const matchLength = matches === null ? 0 : matches.length;
        for (let i = 0; i < matchLength; ++i) {
          newTag.firstElementChild.outerHTML = newTag.firstElementChild.outerHTML.replace(
            matches[i],
            jsOMS2.getArray(matches[i].substring(1, matches[i].length - 1), data)
          );
        }
        if (self2.tagElement.childElementCount >= self2.tagElement.getAttribute("data-limit") && self2.tagElement.getAttribute("data-limit") !== "0") {
          self2.tagElement.removeChild(self2.tagElement.firstElementChild);
        }
        self2.tagElement.appendChild(newTag);
      }
      if (self2.inputField.getAttribute("data-emptyAfter") === "true") {
        self2.inputField.value = "";
      }
      self2.inputField.focus();
    }
    /**
     * Delay handler (e.g. delay after finishing typing)
     *
     * After waiting for a delay a callback can be triggered.
     *
     * @param {Object}        action   Action type
     * @param {function}      callback Callback to be triggered
     * @param {AdvancedInput} self     This reference (passed to callback)
     * @param {Object}        data     Data (passed to callback)
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    inputTimeDelay(action, callback, self2, data) {
      if (_AdvancedInput.timerDelay[action.id]) {
        clearTimeout(_AdvancedInput.timerDelay[action.id]);
        delete _AdvancedInput.timerDelay[action.id];
      }
      _AdvancedInput.timerDelay[action.id] = setTimeout(function() {
        delete _AdvancedInput.timerDelay[action.id];
        callback(self2, data);
      }, action.delay);
    }
  };
  AdvancedInput.timerDelay = {};

  // jsOMS/UI/GeneralUI.js
  var GeneralUI = class {
    /**
     * @constructor
     *
     * @param {Object} app Application object
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.visObs = null;
      this.app = app;
    }
    /**
     * Bind button.
     *
     * @param {null|string} [id] Button id (optional)
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(id = null) {
      let e = null;
      if (id !== null) {
        e = document.getElementById(id);
      }
      this.bindHref(e);
      this.bindIframe(e);
      this.bindLazyLoad(e);
      this.bindInput(e);
    }
    /**
     * Bind & rebind UI element.
     *
     * @param {null|Element} [e] Element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindHref(e = null) {
      e = e !== null ? e.querySelectorAll("[data-href], [href]") : document.querySelectorAll("[data-href], [href]");
      const length = e.length;
      for (let i = 0; i < length; ++i) {
        if (e[i].getAttribute("data-action") !== null) {
          continue;
        }
        e[i].addEventListener("click", function(event) {
          if (event.target.parentElement !== this && event.target.parentElement.getElementsByTagName("input").length > 0 || event.target.getElementsByTagName("input").length > 0) {
            const input = event.target.querySelector("input");
            if (input !== null) {
              input.click();
              return;
            }
          }
          jsOMS2.preventAll(event);
          let uri = this.getAttribute("data-href");
          uri = uri === null ? this.getAttribute("href") : uri;
          if (this.getAttribute("target") === "_blank" || this.getAttribute("data-target") === "_blank" || event.button === 1) {
            window.open(UriFactory.build(uri), "_blank");
          } else if (this.getAttribute("data-redirect") !== null) {
            window.location.href = UriFactory.build(uri);
          } else if (uri !== null) {
            window.location = UriFactory.build(uri);
          }
        });
      }
    }
    /**
     * Bind & rebind UI element.
     *
     * @param {null|Element} [e] Element id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindIframe(e = null) {
      e = e !== null ? e : document.getElementsByTagName("iframe");
      const length = e.length;
      for (let i = 0; i < length; ++i) {
        if (e[i].getAttribute("data-src") !== null) {
          e[i].src = UriFactory.build(e[i].getAttribute("data-src"));
        }
        e[i].addEventListener("load", function() {
          const spinner = this.parentElement.getElementsByClassName("ispinner");
          if (spinner.length > 0) {
            spinner[0].style.display = "none";
          }
        });
      }
    }
    /**
     * Bind & rebind UI element.
     *
     * @param {null|Element} [e] Element id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindLazyLoad(e = null) {
      e = e !== null ? e.querySelectorAll("[data-lazyload]") : document.querySelectorAll("[data-lazyload]");
      const length = e.length;
      if (!this.visObs && window.IntersectionObserver) {
        this.visObs = new IntersectionObserver(function(eles, obs) {
          eles.forEach((ele) => {
            if (ele.intersectionRatio > 0) {
              obs.unobserve(ele.target);
              ele.target.src = ele.target.dataset.lazyload;
              delete ele.target.dataset.lazyload;
            }
          });
        });
      }
      for (let i = 0; i < length; ++i) {
        if (!this.visObs) {
          e[i].src = e[i].dataset.lazyload;
          delete e[i].dataset.lazyload;
        } else {
          this.visObs.observe(e[i]);
        }
      }
    }
    /**
     * Bind & rebind UI element.
     *
     * @param {null|Element} [e] Element id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindInput(e = null) {
      e = e !== null ? [e] : document.getElementsByClassName("advIpt");
      const length = e.length;
      for (let i = 0; i < length; ++i) {
        new AdvancedInput(e[i], this.app.eventManager, this.app.uiManager.getDOMObserver());
      }
    }
    /**
     * Set the value for an elment
     *
     * @param {Element} src   Element to change the value for
     * @param {any}     value Value to set
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    static setValueOfElement(src, value) {
      if (src.hasAttribute("data-value")) {
        src.setAttribute("data-value", value);
        return;
      }
      const tagName = src.tagName.toLowerCase();
      if (tagName === "input") {
        if (src.type === "radio") {
          src.checked = false;
          if (src.value === value) {
            src.checked = true;
          }
        } else if (src.type === "checkbox") {
          src.checked = false;
          const values = value.split(",");
          if (values.includes(src.value)) {
            src.checked = true;
          }
        } else {
          src.value = value;
        }
      } else if (tagName === "select") {
        const optionLength = src.options.length;
        for (let i = 0; i < optionLength; ++i) {
          if (src.options[i].value === value) {
            src.options[i].selected = true;
            break;
          }
        }
      } else if (src.getAttribute("value") !== null) {
        src.value = jsOMS2.htmlspecialchars_decode(value);
      } else {
        src.innerHTML = value;
      }
    }
    /**
     * Set the text for an elment
     *
     * @param {Element} src   Element to change the text for
     * @param {string}  value Text to set
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    static setTextOfElement(src, value) {
      const tagName = src.tagName.toLowerCase();
      if (tagName === "h1") {
        src.innerHTML = jsOMS2.htmlspecialchars_encode(value);
      } else if (src.getAttribute("value") !== null) {
        if (src.value === "") {
          src.value = jsOMS2.htmlspecialchars_decode(value);
        }
      } else if (tagName === "select") {
        const optionLength = src.options.length;
        for (let i = 0; i < optionLength; ++i) {
          if (src.options[i].text === value) {
            src.options[i].selected = true;
            break;
          }
        }
      } else {
        src.innerHTML = value;
      }
    }
    /**
     * Get value from element
     *
     * @param {Element} src Element to get the value from
     *
     * @return {any}
     *
     * @since 1.0.0
     */
    static getValueFromDataSource(src) {
      if (src.getAttribute("data-value") !== null) {
        return src.getAttribute("data-value");
      }
      const tagName = src.tagName.toLowerCase();
      if (tagName === "input" || src.getAttribute("value") !== null) {
        if (src.getAttribute("type") === "radio") {
          const checked = document.querySelector('input[type=radio][name="' + src.name + '"]:checked');
          if (checked === null) {
            return "";
          }
          src = checked;
        } else if (src.getAttribute("type") === "checkbox") {
          if (!src.checked) {
            return "";
          }
        }
        return src.value;
      } else if (tagName === "select") {
        return src.options[src.selectedIndex].value;
      } else {
        return src.innerText.trim(" ");
      }
    }
    /**
     * Get text from element
     *
     * @param {Element} src Element to get the text from
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static getTextFromDataSource(src) {
      const tagName = src.tagName.toLowerCase();
      if (tagName === "input") {
        if (src.getAttribute("type") === "radio") {
          const checked = document.querySelector('input[type=radio][name="' + src.name + '"]:checked');
          if (checked === null) {
            return "";
          }
          return document.querySelector('label[for="' + checked.id + '"]').innerText.trim(" ");
        } else if (src.getAttribute("type") === "checkbox") {
          if (!src.checked) {
            return "";
          }
          return document.querySelector('label[for="' + src.id + '"]').innerText.trim(" ");
        }
        return src.value;
      } else if (tagName === "select") {
        return src.options[src.selectedIndex].text;
      } else if (src.getAttribute("value") !== null) {
        return src.value;
      } else {
        return src.innerHTML.trim(" ");
      }
    }
  };

  // jsOMS/UI/Component/Form.js
  var Form = class _Form {
    /**
     * @constructor
     *
     * @param {Object} app Application
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.app = app;
      this.forms = {};
      this.ignore = {};
    }
    /**
     * Get form
     *
     * @param {string} id Form Id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    get(id) {
      if (!Object.prototype.hasOwnProperty.call(this.forms, id)) {
        this.bind(id);
      }
      return this.forms[id];
    }
    hasChanges() {
      const length = this.forms.length;
      for (let i = 0; i < length; ++i) {
        if (this.forms[i].hasChange()) {
          return true;
        }
      }
      return false;
    }
    /**
     * Is form ignored?
     *
     * @param {string} id Form Id
     *
     * @return {boolean}
     *
     * @since 1.0.0
     */
    isIgnored(id) {
      return this.ignore.indexOf(id) !== -1;
    }
    /**
     * Bind form
     *
     * @param {string} id Form Id (optional, if omitted all forms are searched and bound)
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(id = null) {
      if (id !== null && typeof this.ignore[id] === "undefined") {
        this.bindForm(id);
        return;
      }
      const forms = document.querySelectorAll("form, [data-tag=form]");
      const length = !forms ? 0 : forms.length;
      for (let i = 0; i < length; ++i) {
        const formId = forms[i].getAttribute("id");
        if (typeof formId !== "undefined" && formId !== null && typeof this.ignore[formId] === "undefined") {
          this.bindForm(formId);
        } else {
          Logger2.instance.info("A form doesn't have an ID.");
        }
      }
    }
    /**
     * Bind form
     *
     * @param {null|string} id Form Id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindForm(id = null) {
      if (id === null) {
        Logger2.instance.info("A form doesn't have an ID.");
        return;
      }
      this.forms[id] = new FormView(id);
      const self2 = this;
      let length = 0;
      const toBind = this.forms[id].getElementsToBind();
      const toBindLength = toBind.length;
      for (let i = 0; i < toBindLength; ++i) {
        toBind[i].addEventListener("click", function(event) {
          self2.formActions(self2, event, id);
        });
        if (!this.forms[id].isOnChange()) {
          toBind[i].addEventListener("change", function() {
            if (window.omsApp.state) {
              window.omsApp.state.hasChanges = true;
            }
          });
        }
      }
      const imgPreviews = this.forms[id].getImagePreviews();
      length = imgPreviews === null ? 0 : imgPreviews.length;
      for (let i = 0; i < length; ++i) {
        this.bindImagePreview(imgPreviews[i], id);
      }
      if (this.forms[id].isOnChange()) {
        const hasUiContainer = this.forms[id].getFormElement().getAttribute("data-ui-container");
        const onChangeContainer = hasUiContainer !== null ? this.forms[id].getFormElement().querySelector(hasUiContainer) : this.forms[id].getFormElement();
        onChangeContainer.addEventListener("change", function(event) {
          jsOMS2.preventAll(event);
          if (window.omsApp.state) {
            window.omsApp.state.hasChanges = true;
          }
          const target = event.target.tagName.toLowerCase();
          if (target === "input" || target === "textarea") {
            let dataParent = null;
            if (self2.forms[id].getFormElement().tagName.toLowerCase() === "table") {
              dataParent = event.srcElement.closest(self2.forms[id].getFormElement().getAttribute("data-ui-element"));
            }
            self2.submit(self2.forms[id], null, dataParent, "post");
          }
        });
      }
    }
    formActionRemove(self2, event, id, elementIndex) {
      jsOMS2.preventAll(event);
      const remove = self2.forms[id].getRemove()[elementIndex];
      const callback = function(xhr = null) {
        if (xhr !== null && xhr.status !== 200) {
          self2.app.notifyManager.send(
            new NotificationMessage(
              NotificationLevel.ERROR,
              "Failure",
              "Some failure happened"
            ),
            NotificationType.APP_NOTIFICATION
          );
          return;
        }
        const elementContainer = remove.closest(document.getElementById(id).getAttribute("data-ui-element"));
        window.omsApp.logger.log(document.getElementById(id).getAttribute("data-ui-element"));
        elementContainer.parentNode.removeChild(elementContainer);
      };
      const formElement = document.getElementById(id).getAttribute("action") !== null || document.getElementById(id).getAttribute("data-action") !== null ? self2.forms[id].getFormElement() : document.getElementById(id).getAttribute("data-update-form") !== null ? self2.forms[document.getElementById(id).getAttribute("data-update-form")].getFormElement() : document.getElementById(id).getAttribute("data-delete-form") !== null ? self2.forms[document.getElementById(id).getAttribute("data-delete-form")].getFormElement() : null;
      if (formElement !== null) {
        const deleteRequest = new Request(
          formElement.hasAttribute("data-action-delete") ? formElement.getAttribute("data-action-delete") : formElement.tagName.toLowerCase() !== "form" ? formElement.getAttribute("data-action") : formElement.getAttribute("action"),
          RequestMethod.DELETE
        );
        deleteRequest.setResultCallback(0, callback);
        deleteRequest.send();
      } else {
        callback();
      }
    }
    formActionAdd(self2, event, id, elementIndex) {
      jsOMS2.preventAll(event);
      if (!self2.forms[id].isValid()) {
        return;
      }
      if (document.getElementById(id).getAttribute("data-add-form") === null) {
        this.formActionAddInline(self2, event, id, elementIndex);
      } else {
        this.formActionAddExternal(self2, event, id, elementIndex);
      }
    }
    formActionAddInline(self2, event, id, elementIndex) {
      const formElement = self2.forms[id].getFormElement();
      const uiContainerName = formElement.getAttribute("data-ui-container");
      const uiContainer = uiContainerName.charAt(0) === "#" ? document.querySelector(uiContainerName) : formElement.querySelector(uiContainerName);
      if (formElement.getAttribute("data-update-tpl")) {
        const newElement = uiContainer.querySelector(formElement.getAttribute("data-update-tpl")).content.cloneNode(true);
        uiContainer.appendChild(newElement.firstElementChild);
      } else {
        const newElement = uiContainer.querySelector(formElement.getAttribute("data-add-tpl")).content.cloneNode(true);
        uiContainer.appendChild(newElement.firstElementChild);
      }
    }
    formActionAddExternal(self2, event, id, elementIndex) {
      const formElement = self2.forms[id].getFormElement();
      const uiContainerName = formElement.getAttribute("data-ui-container");
      const uiContainer = uiContainerName.charAt(0) === "#" ? document.querySelector(uiContainerName) : formElement.querySelector(uiContainerName);
      const addTpl = formElement.getAttribute("data-add-tpl").split(",");
      const addTplLength = addTpl.length;
      let vals = [];
      let texts = [];
      const newElements = [];
      for (let i = 0; i < addTplLength; ++i) {
        newElements.push(document.querySelector(addTpl[i]).content.cloneNode(true));
        const tplValue = newElements[i].querySelector("[data-tpl-value]").getAttribute("data-tpl-value");
        const dataOriginElement = tplValue.startsWith("http") || tplValue.startsWith("{") ? newElements[i].firstElementChild : formElement;
        vals = vals.concat(
          dataOriginElement.hasAttribute("data-tpl-value") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-value]"))
        );
        texts = texts.concat(
          dataOriginElement.hasAttribute("data-tpl-text") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-text]"))
        );
        _Form.setRandomIdForElement(newElements[i].firstElementChild);
      }
      const remoteUrls = {};
      self2.forms[id].setSuccess(function(response, xhr) {
        if (xhr.status !== 200) {
          return;
        }
        _Form.setDataInElement("value", newElements, vals, remoteUrls);
        _Form.setDataInElement("text", newElements, texts, remoteUrls);
        for (let i = 0; i < addTplLength; ++i) {
          uiContainer.appendChild(newElements[i].firstElementChild);
        }
        window.omsApp.logger.log(remoteUrls);
        UriFactory.setQuery("$id", response.get("response").id);
        _Form.setDataFromRemoteUrls(remoteUrls);
        self2.forms[id].resetValues();
      });
      self2.submit(self2.forms[id], self2.forms[id].getAdd()[elementIndex]);
    }
    formActionSave(self2, event, id, elementIndex) {
      jsOMS2.preventAll(event);
      if (document.querySelector('[data-update-form="' + id + '"') === null) {
        this.formActionSaveInline(self2, event, id, elementIndex);
      } else {
        this.formActionSaveExternal(self2, event, id, elementIndex);
      }
    }
    formActionSaveInline(self2, event, id, elementIndex) {
      if (!self2.forms[id].isValid()) {
        return;
      }
      const formElement = self2.forms[id].getFormElement();
      const uiContainerName = formElement.getAttribute("data-ui-container");
      const uiContainer = uiContainerName.charAt(0) === "#" ? document.querySelector(uiContainerName) : formElement.querySelector(uiContainerName);
      const updateElementNames = formElement.getAttribute("data-ui-element").split(",");
      const updateElementLength = updateElementNames.length;
      const updateElements = [];
      const elementContainer = event.target.closest(formElement.getAttribute("data-ui-element"));
      let vals = [];
      let texts = [];
      if (elementContainer.getAttribute("data-id") === null || elementContainer.getAttribute("data-id") === "") {
        const addTpl = formElement.getAttribute("data-add-tpl").split(",");
        const addTplLength = addTpl.length;
        const newElements = [];
        for (let i = 0; i < addTplLength; ++i) {
          newElements.push(document.querySelector(addTpl[i]).content.cloneNode(true));
          const tplValue = newElements[i].querySelector("[data-tpl-value]").getAttribute("data-tpl-value");
          const dataOriginElement = tplValue.startsWith("http") || tplValue.startsWith("{") ? newElements[i].firstElementChild : elementContainer;
          vals = vals.concat(
            dataOriginElement.hasAttribute("data-tpl-value") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-value]"))
          );
          texts = texts.concat(
            dataOriginElement.hasAttribute("data-tpl-text") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-text]"))
          );
          _Form.setRandomIdForElement(newElements[i].firstElementChild);
        }
        const remoteUrls = {};
        self2.forms[id].setSuccess(function(response, xhr) {
          if (xhr.status !== 200) {
            return;
          }
          _Form.setDataInElement("value", newElements, vals, remoteUrls);
          _Form.setDataInElement("text", newElements, texts, remoteUrls);
          for (let i = 0; i < addTplLength; ++i) {
            uiContainer.appendChild(newElements[i].firstElementChild);
          }
          elementContainer.parentNode.removeChild(elementContainer);
          window.omsApp.logger.log(remoteUrls);
          UriFactory.setQuery("$id", response.get("response").id);
          _Form.setDataFromRemoteUrls(remoteUrls);
        });
      } else {
        for (let i = 0; i < updateElementLength; ++i) {
          updateElementNames[i] = updateElementNames[i].trim();
          updateElements.push(
            formElement.querySelector(updateElementNames[i] + '[data-id="' + elementContainer.getAttribute("data-id") + '"]')
          );
          const updateValue = updateElements[i].querySelector("[data-tpl-value]").getAttribute("data-tpl-value");
          const dataOriginElement = updateValue.startsWith("http") || updateValue.startsWith("{") ? updateElements[i].firstElementChild : elementContainer;
          vals = vals.concat(
            dataOriginElement.hasAttribute("data-tpl-value") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-value]"))
          );
          texts = texts.concat(
            dataOriginElement.hasAttribute("data-tpl-text") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-text]"))
          );
        }
        const element = uiContainer.querySelector('.vh[data-id="' + elementContainer.getAttribute("data-id") + '"]');
        const remoteUrls = {};
        jsOMS2.removeClass(element, "vh");
        self2.forms[id].setSuccess(function(response, xhr) {
          if (xhr.status !== 200) {
            return;
          }
          _Form.setDataInElement("value", [element], vals, remoteUrls);
          _Form.setDataInElement("text", [element], texts, remoteUrls);
          elementContainer.parentNode.removeChild(elementContainer);
          _Form.setDataFromRemoteUrls(remoteUrls);
        });
      }
    }
    formActionSaveExternal(self2, event, id, elementIndex) {
      const mainForm = document.querySelector('[data-update-form="' + id + '"');
      const externalFormId = id;
      id = mainForm.getAttribute("id");
      if (!self2.forms[id].isValid()) {
        return;
      }
      const formElement = self2.forms[id].getFormElement();
      const externalFormElement = self2.forms[externalFormId].getFormElement();
      const updateElementNames = formElement.getAttribute("data-ui-element").split(",");
      const updateElementLength = updateElementNames.length;
      const updateElements = [];
      let vals = [];
      let texts = [];
      for (let i = 0; i < updateElementLength; ++i) {
        updateElementNames[i] = updateElementNames[i].trim();
        updateElements.push(
          formElement.querySelector(updateElementNames[i] + '[data-id="' + externalFormElement.getAttribute("data-id") + '"]')
        );
        const updateValue = updateElements[i].querySelector("[data-tpl-value]").getAttribute("data-tpl-value");
        const dataOriginElement = updateValue.startsWith("http") || updateValue.startsWith("{") ? updateElements[i].firstElementChild : externalFormElement;
        vals = vals.concat(
          dataOriginElement.hasAttribute("data-tpl-value") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-value]"))
        );
        texts = texts.concat(
          dataOriginElement.hasAttribute("data-tpl-text") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-text]"))
        );
      }
      const remoteUrls = {};
      for (let i = 0; i < updateElementLength; ++i) {
        jsOMS2.removeClass(updateElements[i], "animated");
        jsOMS2.removeClass(updateElements[i], "greenCircleFade");
        window.requestAnimationFrame((_) => {
          window.requestAnimationFrame((_2) => {
            jsOMS2.addClass(updateElements[i], "animated");
            jsOMS2.addClass(updateElements[i], "medium-duration");
            jsOMS2.addClass(updateElements[i], "greenCircleFade");
          });
        });
      }
      self2.forms[externalFormId].setSuccess(function(response, xhr) {
        if (xhr.status !== 200) {
          self2.forms[externalFormId].resetValues();
          return;
        }
        _Form.setDataInElement("value", updateElements, vals, remoteUrls);
        _Form.setDataInElement("text", updateElements, texts, remoteUrls);
        _Form.setDataFromRemoteUrls(remoteUrls);
        for (let i = 0; i < updateElementLength; ++i) {
          jsOMS2.removeClass(updateElements[i], "animated");
          jsOMS2.removeClass(updateElements[i], "greenCircleFade");
          jsOMS2.removeClass(updateElements[i], "medium-duration");
          window.requestAnimationFrame((_) => {
            window.requestAnimationFrame((_2) => {
              jsOMS2.addClass(updateElements[i], "animated medium-duration greenCircleFade");
            });
          });
        }
        self2.forms[externalFormId].resetValues();
      });
      externalFormElement.setAttribute("data-id", "");
      self2.submit(self2.forms[externalFormId], self2.forms[externalFormId].getSave()[elementIndex]);
      const addButtons = self2.forms[externalFormId].getAdd();
      let buttonLength = addButtons.length;
      for (let i = 0; i < buttonLength; ++i) {
        jsOMS2.removeClass(addButtons[i], "vh");
      }
      const saveButtons = self2.forms[externalFormId].getSave();
      buttonLength = saveButtons.length;
      for (let i = 0; i < buttonLength; ++i) {
        jsOMS2.addClass(saveButtons[i], "vh");
      }
      const cancelButtons = self2.forms[externalFormId].getCancel();
      buttonLength = cancelButtons.length;
      for (let i = 0; i < buttonLength; ++i) {
        jsOMS2.addClass(cancelButtons[i], "vh");
      }
    }
    formActionCancel(self2, event, id, elementIndex) {
      const ele = document.getElementById(id);
      if (ele.getAttribute("data-update-form") === null && ele.getAttribute("data-ui-container") !== null && ele.getAttribute("data-ui-element") !== null) {
        this.formActionCancelInline(self2, event, id, elementIndex);
      } else {
        this.formActionCancelExternal(self2, event, id, elementIndex);
      }
    }
    formActionCancelInline(self2, event, id, elementIndex) {
      const formElement = self2.forms[id].getFormElement();
      const uiContainerName = formElement.getAttribute("data-ui-container");
      const uiContainer = uiContainerName.charAt(0) === "#" ? document.querySelector(uiContainerName) : formElement.querySelector(uiContainerName);
      const elementContainer = event.target.closest(formElement.getAttribute("data-ui-element"));
      const element = uiContainer.querySelector('.vh[data-id="' + elementContainer.getAttribute("data-id") + '"]');
      jsOMS2.removeClass(element, "vh");
      elementContainer.parentNode.removeChild(elementContainer);
    }
    formActionCancelExternal(self2, event, id, elementIndex) {
      self2.forms[id].resetValues();
      self2.forms[id].getFormElement().setAttribute("data-id", "");
      let length = 0;
      const addButtons = self2.forms[id].getAdd();
      length = addButtons.length;
      for (let i = 0; i < length; ++i) {
        jsOMS2.removeClass(addButtons[i], "vh");
      }
      const saveButtons = self2.forms[id].getSave();
      length = saveButtons.length;
      for (let i = 0; i < length; ++i) {
        jsOMS2.addClass(saveButtons[i], "vh");
      }
      const cancelButtons = self2.forms[id].getCancel();
      length = cancelButtons.length;
      for (let i = 0; i < length; ++i) {
        jsOMS2.addClass(cancelButtons[i], "vh");
      }
    }
    formActionUpdate(self2, event, id, elementIndex) {
      jsOMS2.preventAll(event);
      if (document.getElementById(id).getAttribute("data-update-form") === null) {
        this.formActionUpdateInline(self2, event, id, elementIndex);
      } else {
        this.formActionUpdateExternal(self2, event, id, elementIndex);
      }
    }
    formActionUpdateInline(self2, event, id, elementIndex) {
      const formElement = self2.forms[id].getFormElement();
      const uiContainerName = formElement.getAttribute("data-ui-container");
      let elementContainer = event.target.closest(formElement.getAttribute("data-ui-element"));
      if (elementContainer === null) {
        elementContainer = formElement.querySelector(formElement.getAttribute("data-ui-element"));
      }
      jsOMS2.addClass(elementContainer, "vh");
      const values = elementContainer.querySelectorAll("[data-tpl-value]");
      const texts = elementContainer.querySelectorAll("[data-tpl-text]");
      const uiContainer = uiContainerName.charAt(0) === "#" ? document.querySelector(uiContainerName) : formElement.querySelector(uiContainerName);
      const addTpl = formElement.getAttribute("data-update-tpl").split(",");
      const addTplLength = addTpl.length;
      const newElements = [];
      for (let i = 0; i < addTplLength; ++i) {
        newElements.push(document.querySelector(addTpl[i]).content.cloneNode(true));
        newElements[i].firstElementChild.setAttribute("data-id", elementContainer.getAttribute("data-id"));
      }
      const remoteUrls = {};
      _Form.setDataInElement("value", newElements, values, remoteUrls);
      _Form.setDataInElement("text", newElements, texts, remoteUrls);
      for (let i = 0; i < addTplLength; ++i) {
        uiContainer.insertBefore(newElements[i].firstElementChild, elementContainer);
      }
      const saveButtons = self2.forms[id].getSave();
      let buttonLength = saveButtons.length;
      for (let i = 0; i < buttonLength; ++i) {
        jsOMS2.removeClass(saveButtons[i], "vh");
      }
      const cancelButtons = self2.forms[id].getCancel();
      buttonLength = cancelButtons.length;
      for (let i = 0; i < buttonLength; ++i) {
        jsOMS2.removeClass(cancelButtons[i], "vh");
      }
      self2.forms[id].setSuccess(function(response) {
        if (response.get("status") !== "undefined" && response.get("status") !== NotificationLevel.HIDDEN) {
          self2.app.notifyManager.send(
            new NotificationMessage(response.get("status"), response.get("title"), response.get("message")),
            NotificationType.APP_NOTIFICATION
          );
        }
        window.omsApp.logger.log(remoteUrls);
        UriFactory.setQuery("$id", response.get("response").id);
        _Form.setDataFromRemoteUrls(remoteUrls);
      });
    }
    formActionUpdateExternal(self2, event, id, elementIndex) {
      const formElement = self2.forms[id].getFormElement();
      const elementContainer = event.target.closest(formElement.getAttribute("data-ui-element"));
      const externalFormId = formElement.getAttribute("data-update-form");
      const values = elementContainer.querySelectorAll("[data-tpl-value]");
      const texts = elementContainer.querySelectorAll("[data-tpl-text]");
      let length = 0;
      self2.forms[externalFormId].resetValues();
      self2.forms[externalFormId].getFormElement().setAttribute("data-id", elementContainer.getAttribute("data-id"));
      const addButtons = self2.forms[externalFormId].getAdd();
      length = addButtons.length;
      for (let i = 0; i < length; ++i) {
        jsOMS2.addClass(addButtons[i], "vh");
      }
      const saveButtons = self2.forms[externalFormId].getSave();
      length = saveButtons.length;
      for (let i = 0; i < length; ++i) {
        jsOMS2.removeClass(saveButtons[i], "vh");
      }
      const cancelButtons = self2.forms[externalFormId].getCancel();
      length = cancelButtons.length;
      for (let i = 0; i < length; ++i) {
        jsOMS2.removeClass(cancelButtons[i], "vh");
      }
      const remoteUrls = {};
      _Form.insertDataIntoForm(self2, "value", externalFormId, values, remoteUrls);
      length = texts.length;
      const length2 = values.length;
      for (let i = 0; i < length; ++i) {
        const tagName = texts[i].tagName.toLowerCase();
        if (tagName === "select") {
          for (let j = 0; j < length2; ++j) {
            if (values[j].getAttribute("name") === texts[i].getAttribute("name")) {
              texts[i] = null;
              break;
            }
          }
        }
      }
      _Form.insertDataIntoForm(self2, "text", externalFormId, texts, remoteUrls);
      self2.forms[externalFormId].setSuccess(function(response) {
        if (response.get("status") !== "undefined" && response.get("status") !== NotificationLevel.HIDDEN) {
          self2.app.notifyManager.send(
            new NotificationMessage(response.get("status"), response.get("title"), response.get("message")),
            NotificationType.APP_NOTIFICATION
          );
        }
        window.omsApp.logger.log(remoteUrls);
        UriFactory.setQuery("$id", response.get("response").id);
        _Form.setDataFromRemoteUrls(remoteUrls);
      });
    }
    formActions(self2, event, id) {
      let elementIndex = 0;
      if ((elementIndex = Array.from(self2.forms[id].getRemove()).indexOf(event.target)) !== -1) {
        this.formActionRemove(self2, event, id, elementIndex);
      } else if ((elementIndex = Array.from(self2.forms[id].getAdd()).indexOf(event.target)) !== -1) {
        this.formActionAdd(self2, event, id, elementIndex);
      } else if ((elementIndex = Array.from(self2.forms[id].getSave()).indexOf(event.target)) !== -1) {
        this.formActionSave(self2, event, id, elementIndex);
      } else if ((elementIndex = Array.from(self2.forms[id].getCancel()).indexOf(event.target)) !== -1) {
        jsOMS2.preventAll(event);
        this.formActionCancel(self2, event, id, elementIndex);
      } else if ((elementIndex = Array.from(self2.forms[id].getUpdate()).indexOf(event.target)) !== -1) {
        this.formActionUpdate(self2, event, id, elementIndex);
      } else if ((elementIndex = Array.from(self2.forms[id].getSubmit()).indexOf(event.target)) !== -1 || (elementIndex = Array.from(self2.forms[id].getSubmit()).indexOf(event.target.parentNode)) !== -1) {
        jsOMS2.preventAll(event);
        self2.submit(self2.forms[id], self2.forms[id].getSubmit()[elementIndex]);
      } else if (false) {
      }
    }
    /**
    * Create the new input
    *
    * @param {string} imageUpload Create form
    * @param {Object} id         Id
    *
    * @return {void}
    *
    * @since  1.0.0
    */
    bindImagePreview(imageUpload, id) {
      imageUpload.addEventListener("change", function() {
        const preview = document.querySelector("#preview-" + imageUpload.getAttribute("name"));
        preview.src = window.URL.createObjectURL(imageUpload.files[0]);
        preview.onload = function() {
          window.URL.revokeObjectURL(this.src);
        };
      });
    }
    /**
     * Submit form
     *
     * Calls injections first before executing the actual form submit
     *
     * @param {FormView} form   Form object
     * @param {Element}  button Action different from the form action (e.g. formaction=*)
     * @param {string}   method Form method
     * @param {string}   action Form action
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    submit(form, button = null, container = null, method = null, action = null) {
      const self2 = this;
      const injects = form.getSubmitInjects();
      let counter = 0;
      if (button !== null) {
        action = button.getAttribute("formaction");
      }
      if (button !== null) {
        method = button.getAttribute("formmethod");
      }
      if (!this.app.eventManager.isAttached(form.getId())) {
        this.app.eventManager.attach(form.getId(), function() {
          self2.submitForm(form, action, method, container);
        }, true);
      }
      for (const property in injects) {
        if (Object.prototype.hasOwnProperty.call(injects, property)) {
          ++counter;
          const result = injects[property](form, form.getId());
          if (result === false) {
            return;
          }
        } else {
          Logger2.instance.warning("Invalid property.");
        }
      }
      if (counter < 1) {
        this.app.eventManager.trigger(form.getId());
      }
      const firstFormInputElement = form.getFirstInputElement();
      if (firstFormInputElement !== null) {
        firstFormInputElement.focus();
      }
    }
    /**
     * Submit form data
     *
     * Submits the main form data
     *
     * @param {FormView} form     Form object
     * @param {string}   [action] Action different from the form action (e.g. formaction=*)
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    submitForm(form, action = null, method = null, container = null) {
      const data = form.getData(container);
      if (!form.isValid(data)) {
        this.app.notifyManager.send(
          new NotificationMessage(
            NotificationLevel.INFO,
            jsOMS2.lang.Info,
            jsOMS2.lang.invalid_form
          ),
          NotificationType.APP_NOTIFICATION
        );
        Logger2.instance.debug('Form "' + form.getId() + '" has invalid values.');
        return;
      }
      if (form.getMethod() !== RequestMethod.GET && Math.abs(Date.now() - form.getLastSubmit()) < 500) {
        return;
      }
      form.updateLastSubmit();
      const request = new Request();
      const self2 = this;
      const redirect = form.getFormElement().getAttribute("data-redirect");
      request.setData(data);
      request.setType(RequestType.FORM_DATA);
      request.setUri(action !== null ? action : form.getAction());
      request.setMethod(method !== null ? method : form.getMethod());
      request.setResultCallback(0, function(xhr) {
        window.omsApp.logger.log(xhr.response);
        const headerLocation = xhr.getResponseHeader("location");
        if (headerLocation !== null) {
          window.location = headerLocation;
        }
        let statusCode = null;
        if (xhr.getResponseHeader("content-type").includes("application/octet-stream")) {
          const blob = new Blob([xhr.response], { type: "application/octet-stream" });
          const doc = document.createElement("a");
          doc.style = "display: none";
          document.body.appendChild(doc);
          const url = window.URL.createObjectURL(blob);
          doc.href = url;
          const disposition = xhr.getResponseHeader("content-disposition");
          let filename = "";
          if (disposition && disposition.indexOf("attachment") !== -1) {
            const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
            const matches = filenameRegex.exec(disposition);
            if (matches !== null && matches[1]) {
              filename = matches[1].replace(/['"]/g, "");
            }
          }
          doc.download = filename;
          doc.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(doc);
        } else if (xhr.getResponseHeader("content-type").includes("text/html")) {
          document.documentElement.innerHTML = xhr.response;
          window.omsApp.reInit();
        } else {
          try {
            const o = JSON.parse(xhr.response)[0];
            const response = new Response(o);
            let successInject = null;
            statusCode = parseInt(xhr.getResponseHeader("status"));
            if ((successInject = form.getSuccess()) !== null && (statusCode === 200 || statusCode === null)) {
              successInject(response, xhr);
              form.setSuccess(null);
            }
            if (response.get("type") !== null) {
              self2.app.responseManager.run(response.get("type"), response.get(), null);
            } else if (typeof o.status !== "undefined" && o.status !== NotificationLevel.HIDDEN) {
              self2.app.notifyManager.send(
                new NotificationMessage(o.status, o.title, o.message),
                NotificationType.APP_NOTIFICATION
              );
            }
          } catch (e) {
            Logger2.instance.log(e);
            Logger2.instance.error(
              "Invalid form response. \nURL: " + form.getAction() + "\nRequest: " + JSON.stringify(form.getData()) + "\nResponse: " + xhr.response
            );
            self2.app.notifyManager.send(
              new NotificationMessage(
                NotificationLevel.ERROR,
                "Failure",
                "Some failure happened"
              ),
              NotificationType.APP_NOTIFICATION
            );
          }
        }
        if (redirect !== null && (statusCode === 200 || statusCode === null)) {
          fetch(UriFactory.build(redirect)).then((response) => response.text()).then((html) => {
            document.documentElement.innerHTML = html;
            if (window.omsApp.state) {
              window.omsApp.state.hasChanges = false;
            }
            history.pushState({}, null, UriFactory.build(redirect));
            window.omsApp.reInit();
          }).catch((error) => {
            console.warn(error);
          });
        }
      });
      if (window.omsApp.state) {
        window.omsApp.state.hasChanges = false;
      }
      request.send();
      if (form.getFinally() !== null) {
        form.getFinally()();
      }
    }
    /**
     * Count the bound forms
     *
     * @return {int}
     *
     * @since 1.0.0
     */
    count() {
      return this.forms.length;
    }
    static setDataFromRemoteUrls(remoteUrls) {
      for (const e in remoteUrls) {
        const request = new Request(e);
        request.setResultCallback(200, function(xhr) {
          const remoteUrlsLength = remoteUrls[e].length;
          for (let k = 0; k < remoteUrlsLength; ++k) {
            const path = remoteUrls[e][k].path;
            if (remoteUrls[e][k].type === "value") {
              GeneralUI.setValueOfElement(
                remoteUrls[e][k].element,
                path !== null ? jsOMS2.getArray(path, JSON.parse(xhr.response)) : xhr.response
              );
            } else {
              GeneralUI.setTextOfElement(
                remoteUrls[e][k].element,
                path !== null ? jsOMS2.getArray(path, JSON.parse(xhr.response)) : xhr.response
              );
            }
          }
        });
        request.send();
      }
    }
    /**
     * Set random data-id of a element
     *
     * @param {HTMLElement} element Element to set the data-id for
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    static setRandomIdForElement(element) {
      if (element.getAttribute("data-id") !== null && element.getAttribute("data-id") !== "") {
        return;
      }
      let eleId = "";
      do {
        eleId = "r-" + Math.random().toString(36).substring(7);
      } while (document.querySelector('[data-id="' + eleId + '"]') !== null);
      element.setAttribute("data-id", eleId);
      return eleId;
    }
    static setDataInElement(type, elements, data, remoteUrls = {}) {
      const changedNodes = [];
      const length = data.length;
      const elementsLength = elements.length;
      for (let i = 0; i < length; ++i) {
        const path = data[i].hasAttribute("data-tpl-" + type + "-path") ? data[i].getAttribute("data-tpl-" + type + "-path") : null;
        for (let j = 0; j < elementsLength; ++j) {
          const element = elements[j] instanceof DocumentFragment ? elements[j].firstElementChild : elements[j];
          const matches = element.hasAttribute("data-tpl-" + type) && element.getAttribute("data-tpl-" + type) === data[i].getAttribute("data-tpl-" + type) ? [element] : element.querySelectorAll(
            "[data-tpl-" + type + '="' + data[i].getAttribute("data-tpl-" + type) + '"'
          );
          const matchLength = matches.length;
          for (let c = 0; c < matchLength; ++c) {
            if (changedNodes.includes(matches[c]) || path !== null && path !== matches[c].getAttribute("data-tpl-" + type + "-path")) {
              continue;
            }
            changedNodes.push(matches[c]);
            if (data[i].getAttribute("data-tpl-" + type).startsWith("http") || data[i].getAttribute("data-tpl-" + type).startsWith("{")) {
              _Form.populateRemoteUrls(matches[c], type, data[i], path, remoteUrls);
            } else {
              if (type === "value") {
                GeneralUI.setValueOfElement(matches[c], GeneralUI.getValueFromDataSource(data[i]));
              } else if (type === "text") {
                GeneralUI.setTextOfElement(matches[c], GeneralUI.getTextFromDataSource(data[i]));
              }
            }
          }
        }
      }
    }
    static insertDataIntoForm(self2, type, formId, data, remoteUrls = {}) {
      const length = data.length;
      for (let i = 0; i < length; ++i) {
        if (data[i] === null) {
          continue;
        }
        const matches = self2.forms[formId].getFormElement().querySelectorAll("[data-tpl-" + type + '="' + data[i].getAttribute("data-tpl-" + type) + '"');
        const path = data[i].hasAttribute("data-tpl-" + type + "-path") ? data[i].getAttribute("data-tpl-" + type + "-path") : null;
        const matchLength = matches.length;
        for (let c = 0; c < matchLength; ++c) {
          if (data[i].getAttribute("data-tpl-" + type).startsWith("http") || data[i].getAttribute("data-tpl-" + type).startsWith("{")) {
            _Form.populateRemoteUrls(matches[c], type, data[i], path, remoteUrls);
          } else {
            if (type === "value") {
              GeneralUI.setValueOfElement(matches[c], GeneralUI.getValueFromDataSource(data[i]));
            } else if (type === "text" && (data[i].getAttribute("data-tpl-text") !== data[i].getAttribute("data-tpl-value") || data[i].getAttribute("data-value") !== null)) {
              GeneralUI.setTextOfElement(matches[c], GeneralUI.getTextFromDataSource(data[i]));
            }
          }
        }
      }
    }
    static populateRemoteUrls(ele, type, data, path, remoteUrls) {
      const uri = data.getAttribute("data-tpl-" + type).startsWith("/") ? document.getElementsByTagName("base")[0].href : "";
      if (remoteUrls[uri + data.getAttribute("data-tpl-" + type)] === void 0) {
        remoteUrls[uri + data.getAttribute("data-tpl-" + type)] = [];
      }
      remoteUrls[uri + data.getAttribute("data-tpl-" + type)].push({
        path,
        element: ele,
        type
      });
    }
  };

  // jsOMS/UI/Component/Tab.js
  var Tab = class {
    /**
     * @constructor
     *
     * @param {Object} app Application
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.app = app;
    }
    /**
     * Bind & rebind UI elements.
     *
     * @param {null|string} [id] Element id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(id = null) {
      if (id !== null) {
        const e = document.getElementById(id);
        if (e) {
          this.bindElement(e);
        }
        return;
      }
      const tabs = document.getElementsByClassName("tabview");
      const length = !tabs ? 0 : tabs.length;
      for (let i = 0; i < length; ++i) {
        this.bindElement(tabs[i]);
      }
    }
    /**
     * Bind & rebind UI element.
     *
     * @param {Element} e Element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindElement(e) {
      const nodes = e.querySelectorAll(".tab-links li");
      const length = nodes.length;
      for (let i = 0; i < length; ++i) {
        nodes[i].addEventListener("click", function(evt) {
          let fragmentString = this.querySelector("label").getAttribute("for");
          const oldActive = this.parentNode.getElementsByClassName("active");
          if (oldActive.length > 0) {
            const fragments2 = fragmentString.split("&");
            const index = fragments2.indexOf(oldActive[0].getElementsByTagName("label")[0].getAttribute("for"));
            if (index > -1) {
              fragments2.splice(index, 1);
            }
            fragmentString = fragments2.join("&");
            jsOMS2.removeClass(oldActive[0], "active");
          }
          const fragments = fragmentString.split("&");
          fragmentString = fragments.join("&");
          jsOMS2.addClass(this, "active");
          if (jsOMS2.hasClass(this.closest(".tabview"), "url-rewrite")) {
            window.history.replaceState(
              null,
              "",
              UriFactory.build(
                "{%}#" + (fragmentString === "" ? "" : fragmentString)
              )
            );
          }
        });
      }
      this.activateTabUri(e);
    }
    /**
     * Activates the correct tab based on URI fragment.
     *
     * This allows to link a specific open tab to a user or make it a bookmark
     *
     * @param {Element} e Element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    activateTabUri(e) {
      const fragmentString = window.location.href.includes("#") ? HttpUri.parseUrl(window.location.href).fragment : "";
      if (fragmentString === null || typeof fragmentString === "undefined") {
        return;
      }
      const fragments = fragmentString.split("&");
      const fragLength = fragments.length;
      if (fragLength > 0 && fragmentString !== "") {
        for (let i = 0; i < fragLength; ++i) {
          const label = e.querySelector('label[for="' + fragments[i] + '"]');
          if (typeof label !== "undefined" && label !== null) {
            label.click();
          }
        }
      }
      if (e.querySelector(".tab-links")?.querySelector(".active") === null) {
        e.querySelector(".tab-links").querySelector("label").click();
      }
    }
  };

  // jsOMS/Views/TableView.js
  var TableView = class {
    /**
     * @constructor
     *
     * @param {string} id Table id
     *
     * @since 1.0.0
     */
    constructor(id) {
      this.id = id;
      this.table = null;
    }
    /**
     * Bind the table
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind() {
      this.table = document.getElementById(this.id);
    }
    /**
     * Serialize table data
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    serialize() {
      const table = document.getElementById(this.id);
      const data = {
        caption: null,
        header: [],
        rows: []
      };
      data.caption = table.getElementsByTagName("caption")[0].innerText;
      const header = table.querySelectorAll("thead tr td, thead tr th");
      const headerLength = header.length;
      for (let i = 0; i < headerLength; ++i) {
        data.header.push(header[i].innerText);
      }
      const rows = table.querySelectorAll("tbody tr");
      const rowsLength = rows.length;
      for (let i = 0; i < rowsLength; ++i) {
        data.rows[i] = [];
        const columns = rows[i].querySelectorAll("td, th");
        const columnLength = columns.length;
        for (let j = 0; j < columnLength; ++j) {
          data.rows[i].push(columns[j].innerText);
        }
      }
      return data;
    }
    /**
     * Get table export button
     *
     * @return {HTMLElement}
     *
     * @since 1.0.0
     */
    getExport() {
      return document.querySelectorAll("#" + this.id + " .download")[0];
    }
    /**
     * Get table header elements which provide sorting
     *
     * @return {Array}
     *
     * @since 1.0.0
     */
    getSorting() {
      return document.querySelectorAll(
        "#" + this.id + " thead .sort-asc, #" + this.id + " thead .sort-desc"
      );
    }
    /**
     * Get table header elements which provide filter functionality
     *
     * @return {Array}
     *
     * @since 1.0.0
     */
    getFilter() {
      return document.querySelectorAll(
        "#" + this.id + " .filter"
      );
    }
    /**
     * Get table header
     *
     * @return {Array}
     *
     * @since 1.0.0
     */
    getHeader() {
      return document.querySelector(
        "#" + this.id + " thead"
      );
    }
    /**
     * Get table header elements which provide filter functionality
     *
     * @return {Array}
     *
     * @since 1.0.0
     */
    getCheckboxes() {
      return document.querySelectorAll(
        "#" + this.id + " thead input[type=checkbox]"
      );
    }
    /**
     * Get row elements which allow to swap the current row with another row
     *
     * @return {Array}
     *
     * @since 1.0.0
     */
    getSortableRows() {
      return document.querySelectorAll(
        "#" + this.id + " tbody .order-up, #" + this.id + " tbody .order-down"
      );
    }
  };

  // jsOMS/UI/Component/Table.js
  var Table = class _Table {
    /**
     * @constructor
     *
     * @param {Object} app Application
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.app = app;
      this.tables = {};
      this.ignore = {};
    }
    /**
     * Bind & rebind UI elements.
     *
     * @param {null|string} [id] Element id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(id = null) {
      if (id !== null && typeof this.ignore[id] === "undefined") {
        this.bindTable(id);
        return;
      }
      const tables = document.getElementsByTagName("table");
      const length = !tables ? 0 : tables.length;
      for (let i = 0; i < length; ++i) {
        const tableId = tables[i].getAttribute("id");
        if (typeof tableId !== "undefined" && tableId !== null && typeof this.ignore[tableId] === "undefined") {
          this.bindTable(tableId);
        }
      }
    }
    /**
     * Bind & rebind UI element.
     *
     * @param {Object} id Element id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindTable(id = null) {
      if (id === null) {
        jsOMS2.Log.Logger.instance.info("A table doesn't have an ID.");
        return;
      }
      this.tables[id] = new TableView(id);
      this.bindExport(this.tables[id]);
      const sorting = this.tables[id].getSorting();
      let length = sorting.length;
      for (let i = 0; i < length; ++i) {
        this.bindSorting(sorting[i], id);
      }
      const filters = this.tables[id].getFilter();
      length = filters.length;
      for (let i = 0; i < length; ++i) {
        this.bindFiltering(filters[i], id);
      }
      const checkboxes = this.tables[id].getCheckboxes();
      length = checkboxes.length;
      for (let i = 0; i < length; ++i) {
        this.bindCheckbox(checkboxes[i], id);
      }
      const header = this.tables[id].getHeader();
      this.bindColumnVisibility(header, id);
    }
    /**
     * Export a table
     *
     * @param {Element} exports Export button
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindExport(exports) {
      const button = exports.getExport();
      if (typeof button === "undefined" || button === null) {
        return;
      }
      button.addEventListener("click", function(event) {
        window.omsApp.logger.log(exports.serialize());
      });
    }
    /**
     * Bind column visibility
     *
     * @param {Element} header Header
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindColumnVisibility(header) {
      const self2 = this;
      const columns = header.querySelectorAll("td");
      const length = columns.length;
      for (let i = 0; i < length; ++i) {
        const state = JSON.parse(window.localStorage.getItem("ui-state-" + this.id + "-header-" + i));
        const rows = header.parentElement.getElementsByTagName("tr");
        const rowLength = rows.length;
        if (state === "1" && !jsOMS2.hasClass(columns[i], "vh")) {
          for (let j = 0; j < rowLength; ++j) {
            const cols = rows[j].getElementsByTagName("td");
            if (cols.length < length) {
              continue;
            }
            jsOMS2.addClass(cols[i], "vh");
          }
        } else if ((state === "0" || state === null) && jsOMS2.hasClass(columns[i], "vh")) {
          for (let j = 0; j < rowLength; ++j) {
            const cols = rows[j].getElementsByTagName("td");
            if (cols.length < length) {
              continue;
            }
            jsOMS2.removeClass(cols[i], "vh");
          }
        }
      }
      header.addEventListener("contextmenu", function(event) {
        jsOMS2.preventAll(event);
        if (document.getElementById("table-ctx-menu") !== null) {
          return;
        }
        const tpl = document.getElementById("table-ctx-menu-tpl");
        if (tpl === null) {
          return;
        }
        const output = document.importNode(tpl.content, true);
        tpl.parentNode.appendChild(output);
        const menu = document.getElementById("table-ctx-menu");
        const columns2 = header.querySelectorAll("td");
        const length2 = columns2.length;
        const baseMenuLine = menu.getElementsByClassName("context-line")[0].cloneNode(true);
        for (let i = 0; i < length2; ++i) {
          if (columns2[i].firstElementChild.innerText.trim() === "") {
            continue;
          }
          const menuLine = baseMenuLine.cloneNode(true);
          const lineId = menuLine.firstElementChild.getAttribute("get") + i;
          menuLine.firstElementChild.setAttribute("for", lineId);
          menuLine.firstElementChild.firstElementChild.setAttribute("id", lineId);
          menuLine.firstElementChild.appendChild(document.createTextNode(columns2[i].firstElementChild.innerText.trim()));
          const isHidden = jsOMS2.hasClass(columns2[i], "vh");
          menu.getElementsByTagName("ul")[0].appendChild(menuLine);
          menu.querySelector("ul").lastElementChild.querySelector('input[type="checkbox"]').checked = !isHidden;
          menu.querySelector("ul").lastElementChild.querySelector('input[type="checkbox"]').addEventListener("change", function() {
            const rows = header.parentElement.getElementsByTagName("tr");
            const rowLength = rows.length;
            const isHidden2 = jsOMS2.hasClass(columns2[i], "vh");
            if (isHidden2) {
              window.localStorage.setItem("ui-state-" + self2.id + "-header-" + i, JSON.stringify("0"));
            } else {
              window.localStorage.setItem("ui-state-" + self2.id + "-header-" + i, JSON.stringify("1"));
            }
            for (let j = 0; j < rowLength; ++j) {
              const cols = rows[j].getElementsByTagName("td");
              if (isHidden2) {
                jsOMS2.removeClass(cols[i], "vh");
              } else {
                jsOMS2.addClass(cols[i], "vh");
              }
            }
          });
        }
        menu.getElementsByTagName("ul")[0].removeChild(menu.getElementsByClassName("context-line")[0]);
        const rect = tpl.parentElement.getBoundingClientRect();
        menu.style.top = event.clientY - rect.top + "px";
        menu.style.left = event.clientX - rect.left + "px";
        document.addEventListener("click", _Table.hideMenuClickHandler);
      });
    }
    static hideMenuClickHandler(event) {
      const menu = document.getElementById("table-ctx-menu");
      const isClickedOutside = !menu.contains(event.target);
      if (isClickedOutside) {
        menu.parentNode.removeChild(menu);
        document.removeEventListener("click", _Table.hideMenuClickHandler);
      }
    }
    /**
     * Sorts the table.
     *
     * @param {Element} sorting Sort button
     * @param {string}  id      Table id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindSorting(sorting, id) {
      sorting.addEventListener("click", function(event) {
        if (this.firstElementChild === null || this.firstElementChild.tagName.toLowerCase() === "a") {
          return;
        }
        const table = document.getElementById(id);
        const rows = table.getElementsByTagName("tbody")[0].rows;
        const rowLength = rows.length;
        const cellId = this.closest("td").cellIndex;
        const sortType = jsOMS2.hasClass(this, "sort-asc") ? 1 : -1;
        let j;
        let i;
        let row1;
        let row2;
        let content1;
        let content2;
        let order = false;
        let shouldSwitch = false;
        const columnName = this.closest("td").getAttribute("data-name");
        table.setAttribute("data-sorting", (sortType > 0 ? "+" : "-") + (columnName !== null ? columnName : cellId));
        if (table.getAttribute("data-src") !== null) {
          _Table.getRemoteData(table);
          return;
        }
        do {
          order = false;
          for (j = 0; j < rowLength - 1; ++j) {
            shouldSwitch = false;
            row1 = rows[j].getElementsByTagName("td")[cellId];
            content1 = row1.getAttribute("data-content") !== null ? row1.getAttribute("data-content").toLowerCase() : row1.textContent.toLowerCase();
            content1 = !isNaN(content1) ? parseFloat(content1) : !isNaN(new Date(content1)) ? new Date(content1) : content1;
            for (i = j + 1; i < rowLength; ++i) {
              row2 = rows[i].getElementsByTagName("td")[cellId];
              content2 = row2.getAttribute("data-content") !== null ? row2.getAttribute("data-content").toLowerCase() : row2.textContent.toLowerCase();
              content2 = !isNaN(content2) ? parseFloat(content2) : !isNaN(new Date(content2)) ? new Date(content2) : content2;
              if (sortType === 1 && content1 > content2) {
                shouldSwitch = true;
                break;
              } else if (sortType === -1 && content1 < content2) {
                shouldSwitch = true;
                break;
              }
            }
            if (shouldSwitch === true) {
              break;
            }
          }
          if (shouldSwitch) {
            rows[j].parentNode.insertBefore(rows[i], rows[j]);
            order = true;
          }
        } while (order);
      });
    }
    /**
     * Filters the table.
     *
     * @param {Element} filtering Filter button
     * @param {string}  id        Table id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindFiltering(filtering, id) {
      filtering.addEventListener("click", function(event) {
      });
    }
    /**
     * Checkbox select.
     *
     * @param {Element} checkbox Filter button
     * @param {string}  id       Table id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindCheckbox(checkbox, id) {
      checkbox.addEventListener("click", function(event) {
        const columnId = checkbox.closest("td").cellIndex;
        const rows = checkbox.closest("table").querySelectorAll("tbody tr");
        const rowLength = rows.length;
        const status = checkbox.checked;
        for (let i = 0; i < rowLength; ++i) {
          if (typeof rows[i].cells[columnId] === "undefined") {
            break;
          }
          const box = rows[i].cells[columnId].querySelector("input[type=checkbox]");
          if (box !== null) {
            box.checked = status;
          }
        }
      });
    }
    static getRemoteData(table) {
      const data = {
        limit: table.getAttribute("data-limit"),
        offset: table.getAttribute("data-offset"),
        sorting: table.getAttribute("data-sorting"),
        filter: table.getAttribute("data-filter")
      };
      const request = new Request();
      request.setData(data);
      request.setType(ResponseType.JSON);
      request.setUri(table.getAttribute("data-src"));
      request.setMethod("GET");
      request.setRequestHeader("Content-Type", "application/json");
      request.setSuccess(function(xhr) {
        _Table.emptyTable(table.getElementsByTagName("tbody")[0]);
        _Table.addToTable(table.getElementsByTagName("tbody")[0], JSON.parse(xhr.response)[0]);
      });
      request.send();
    }
    static emptyTable(table) {
      const rows = table.getElementsByTagName("tr");
      const length = rows.length;
      for (let i = 0; i < length; ++i) {
        rows[i].parentNode.removeChild(rows[i]);
      }
    }
    static addToTable(table, data) {
      const dataLength = data.length;
      console.table(data);
      for (let i = 0; i < dataLength; ++i) {
        const newRow = table.getElementsByTagName("template")[0].content.cloneNode(true);
        let fields = newRow.querySelectorAll("[data-tpl-text]");
        let fieldLength = fields.length;
        for (let j = 0; j < fieldLength; ++j) {
          fields[j].appendChild(
            document.createTextNode(
              jsOMS2.getArray(fields[j].getAttribute("data-tpl-text"), data[i])
            )
          );
        }
        fields = newRow.querySelectorAll("[data-tpl-value]");
        fieldLength = fields.length;
        for (let j = 0; j < fieldLength; ++j) {
          fields[j].setAttribute(
            "data-value",
            jsOMS2.getArray(fields[j].getAttribute("data-tpl-value"), data[i])
          );
        }
        table.appendChild(newRow);
      }
    }
  };

  // jsOMS/UI/ActionManager.js
  var ActionManager = class {
    /**
     * @constructor
     *
     * @param {Object} app Application
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.logger = Logger2.getInstance();
      this.app = app;
      this.actions = {};
    }
    /**
     * Bind element.
     *
     * @param {null|string} [id] Element id (optional)
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(id = null) {
      const uiElements = id == null ? document.querySelectorAll("[data-action]") : typeof id.length !== "undefined" ? id : [id];
      const length = uiElements.length;
      for (let i = 0; i < length; ++i) {
        if (uiElements[i] !== null && uiElements[i].hasAttribute("data-action")) {
          this.bindElement(uiElements[i]);
        }
      }
    }
    /**
     * Bind element.
     *
     * @param {Element} e Element to bind
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindElement(e) {
      if (!jsOMS2.isValidJson(e.getAttribute("data-action"))) {
        this.logger.error("Invalid json string: '" + e.getAttribute("data-action") + "'");
        return;
      }
      const listeners = JSON.parse(e.getAttribute("data-action"));
      const listenerLength = listeners.length;
      const self2 = this;
      for (let i = 0; i < listenerLength; ++i) {
        let c = [e];
        let hasSelector = false;
        if (Object.prototype.hasOwnProperty.call(listeners[i], "selector")) {
          c = document.querySelectorAll(listeners[i].selector);
          hasSelector = true;
        }
        const childLength = c.length;
        for (let j = 0; j < childLength; ++j) {
          this.bindListener(c[j].id, listeners[i]);
        }
        const observeConfig = { childList: false, attributes: true, subtree: false };
        if (hasSelector) {
          this.app.eventManager.attach(e.id + "-childList", function(data) {
            const length = data.addedNodes.length;
            for (let j = 0; j < length; ++j) {
              self2.bindListener(
                data.addedNodes[j].id,
                listeners[i],
                typeof listeners[i].autoremove !== "undefined" ? listeners[i].autoremove : false
              );
            }
          });
          observeConfig.childList = true;
          observeConfig.subtree = true;
        }
        this.app.eventManager.attach(e.id + "-attributes", function(data) {
        });
        this.app.uiManager.getDOMObserver().observe(e, observeConfig);
      }
    }
    /**
     * Bind listener for object
     *
     * @param {string} id Element to bind
     * @param {Object} listener Listener object
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindListener(id, listener, removable = false) {
      const self2 = this;
      const actionLength = listener.action.length;
      for (let j = 1; j < actionLength; ++j) {
        if (typeof id === "undefined" || typeof listener.key === "undefined") {
          this.logger.error("Invalid element id/key: " + id + "/" + listener.key);
          return;
        }
        if (this.app.eventManager.isAttached(id + "-" + listener.key + "-" + listener.action[j - 1].key)) {
          return;
        }
        this.app.eventManager.attach(id + "-" + listener.key + "-" + listener.action[j - 1].key, function(data) {
          self2.runAction(id, listener, listener.action[j], data);
        }, removable, true);
      }
      document.getElementById(id).addEventListener(listener.listener, function(event) {
        if (listener.preventDefault) {
          jsOMS2.preventAll(event);
        }
        self2.runAction(this.id, listener, listener.action[0], event);
      }, false);
    }
    /**
     * Run event action.
     *
     * @param {string} id       Element
     * @param {Object} listener Listener
     * @param {Object} action   Action
     * @param {Object} data     Data for the next action
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    runAction(id, listener, action, data) {
      const self2 = this;
      if (!Object.prototype.hasOwnProperty.call(this.actions, action.type)) {
        this.logger.warning("Undefined action " + action.type);
        return;
      }
      action.data = data;
      this.actions[action.type](action, function(data2) {
        self2.app.eventManager.trigger(id + "-" + listener.key + "-" + action.key, id, data2);
      }, id);
    }
    /**
     * Add action callback.
     *
     * @param {string}   name     Action identifier
     * @param {function} callback Action callback
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    add(name, callback) {
      this.actions[name] = callback;
    }
  };

  // jsOMS/UI/DragNDrop.js
  var DragNDrop = class {
    /**
     * @constructor
     *
     * @param {Object} app Application
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.app = app;
      this.draggable = {};
      this.dragging = null;
    }
    /**
     * Bind element
     *
     * @param {null|Element} element DOM element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(element = null) {
      if (element !== null) {
        this.bindElement(element);
      } else {
        const elements = document.querySelectorAll(".oms-dragcontainer");
        const length = !elements ? 0 : elements.length;
        for (let i = 0; i < length; ++i) {
          this.bindElement(elements[i]);
        }
      }
    }
    /**
     * Bind DOM element
     *
     * @param {Element} element DOM element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindElement(element) {
      const self2 = this;
      if (!element) {
        return;
      }
      element.addEventListener("dragstart", function(e) {
        if (self2.dragging === null) {
          self2.dragging = e.target;
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/html", e.target.innerHTML);
        }
      }, false);
      element.addEventListener("dragenter", function(e) {
        const thisElement = e.target.closest(".oms-dragcontainer " + this.children[this.children.length - 1].tagName);
        const rowIndex = Array.from(this.children).indexOf(thisElement);
        const dragIndex = Array.from(self2.dragging.children).indexOf(self2.dragging);
        const oldPlaceholder = this.querySelector(".oms-drag-placeholder");
        if (oldPlaceholder !== null) {
          this.removeChild(oldPlaceholder);
        }
        const placeholder = document.createElement(self2.dragging.tagName);
        if (self2.dragging.tagName.toLowerCase() === "tr") {
          const placeholderTd = document.createElement("td");
          placeholderTd.setAttribute("colspan", 42);
          placeholder.appendChild(placeholderTd);
        }
        placeholder.setAttribute("draggable", "true");
        jsOMS2.addClass(placeholder, "oms-drag-placeholder");
        if (dragIndex < rowIndex) {
          this.insertBefore(placeholder, thisElement.nextSibling);
        } else {
          this.insertBefore(placeholder, thisElement);
        }
      }, false);
      element.addEventListener("dragover", function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      }, false);
      element.addEventListener("dragleave", function(e) {
        e.preventDefault();
      }, false);
      element.addEventListener("dragend", function(e) {
        e.preventDefault();
        const oldPlaceholder = this.querySelector(".oms-drag-placeholder");
        if (oldPlaceholder === null) {
          return;
        }
        this.insertBefore(self2.dragging, oldPlaceholder);
        this.removeChild(oldPlaceholder);
        self2.dragging = null;
      }, false);
      element.addEventListener("drop", function(e) {
        e.stopPropagation();
        e.preventDefault();
      }, false);
    }
  };

  // jsOMS/UI/Order.js
  var Order = class {
    /**
     * @constructor
     *
     * @param {Object} app Application
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.app = app;
    }
    /**
     * Bind element
     *
     * @param {Object} [element] DOM element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(element = null) {
      if (element !== null) {
        this.bindElement(element);
        return;
      }
      const elements = document.querySelectorAll(".oms-ordercontainer");
      const length = !elements ? 0 : elements.length;
      for (let i = 0; i < length; ++i) {
        this.bindElement(elements[i]);
      }
    }
    /**
     * Bind DOM element
     *
     * @param {string} id DOM element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindElement(element) {
      if (!element) {
        return;
      }
      element.addEventListener("click", function(event) {
        if (!jsOMS2.hasClass(event.target, "order-up") && !jsOMS2.hasClass(event.target, "order-down")) {
          return;
        }
        jsOMS2.preventAll(event);
        const rowLength = element.children.length;
        const thisElement = event.target.closest(".oms-ordercontainer " + this.children[rowLength - 1].tagName);
        const rowId = Array.from(element.children).indexOf(thisElement);
        const orderType = jsOMS2.hasClass(event.target, "order-up") ? 1 : -1;
        if (orderType === 1 && rowId > 0) {
          element.insertBefore(element.children[rowId], element.children[rowId - 1]);
        } else if (orderType === -1 && rowId < rowLength) {
          element.insertBefore(element.children[rowId], element.children[rowId + 2]);
        }
      }, false);
    }
  };

  // jsOMS/UI/RemoteData.js
  var RemoteData = class _RemoteData {
    /**
     * @constructor
     *
     * @param {Object} app Application
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.app = app;
    }
    /**
     * Bind element
     *
     * @param {Object} [element] DOM element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind() {
      const elements = document.querySelectorAll(".oms-remotecontainer");
      const length = !elements ? 0 : elements.length;
      setInterval(function() {
        for (let i = 0; i < length; ++i) {
          const uri = elements[i].getAttribute("data-remote-uri");
          const uiContainer = elements[i];
          const request = new Request();
          request.setData({});
          request.setType(RequestType.JSON);
          request.setUri(uri);
          request.setMethod(RequestMethod.GET);
          request.setSuccess(function(xhr) {
            const data = JSON.parse(xhr.response);
            const responseLength = data.length;
            let currentElement = null;
            for (let i2 = 0; i2 < responseLength; ++i2) {
              const childElements2 = uiContainer.querySelectorAll(uiContainer.getAttribute("data-ui-element"));
              currentElement = childElements2.length - 1 < i2 ? null : childElements2[i2];
              if (currentElement === null || currentElement.getAttribute("data-id") !== data[i2].id) {
                const addTpl = uiContainer.getAttribute("data-add-tpl").split(",");
                const addTplLength = addTpl.length;
                let values = [];
                let texts = [];
                const newElements = [];
                for (let j = 0; j < addTplLength; ++j) {
                  newElements.push(document.querySelector(addTpl[j]).content.cloneNode(true));
                  const dataOriginElement = newElements[j].firstElementChild;
                  values = values.concat(
                    dataOriginElement.hasAttribute("data-tpl-value") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-value]"))
                  );
                  texts = texts.concat(
                    dataOriginElement.hasAttribute("data-tpl-text") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-text]"))
                  );
                }
                _RemoteData.setRemoteData("text", texts, data[i2]);
                _RemoteData.setRemoteData("value", values, data[i2]);
                for (let j = 0; j < addTplLength; ++j) {
                  if (currentElement === null) {
                    uiContainer.appendChild(newElements[j].firstElementChild);
                  } else {
                    uiContainer.insertBefore(newElements[j].firstElementChild, currentElement);
                  }
                }
                continue;
              } else if (currentElement !== null && currentElement.getAttribute("data-id") === data[i2].id) {
                let values = [];
                let texts = [];
                const dataOriginElement = currentElement;
                values = values.concat(
                  dataOriginElement.hasAttribute("data-tpl-value") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-value]"))
                );
                texts = texts.concat(
                  dataOriginElement.hasAttribute("data-tpl-text") ? dataOriginElement : Array.prototype.slice.call(dataOriginElement.querySelectorAll("[data-tpl-text]"))
                );
                _RemoteData.setRemoteData("text", texts, data[i2]);
                _RemoteData.setRemoteData("value", values, data[i2]);
              }
            }
            const childElements = elements[i].querySelectorAll(elements[i].getAttribute("data-ui-element"));
            const childLength = childElements.length;
            for (let i2 = responseLength; i2 < childLength; ++i2) {
              uiContainer.removeChild(childElements[i2]);
            }
          });
          request.send();
        }
      }, 30 * 1e3);
    }
    static setRemoteData(type, elements, data = {}) {
      const elementsLength = elements.length;
      for (let i = 0; i < elementsLength; ++i) {
        const path = elements[i].hasAttribute("data-tpl-" + type + "-path") ? elements[i].getAttribute("data-tpl-" + type + "-path") : null;
        if (path === null) {
          continue;
        }
        if (type === "value") {
          GeneralUI.setValueOfElement(elements[i], jsOMS2.getArray(path, data));
        } else {
          GeneralUI.setTextOfElement(elements[i], jsOMS2.getArray(path, data));
        }
      }
    }
  };

  // jsOMS/UI/UIStateManager.js
  var UIStateManager = class {
    /**
     * @constructor
     *
     * @param {Object} app Application
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.app = app;
    }
    /**
     * Bind element
     *
     * @param {Object} [element] DOM element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(element = null) {
      if (element !== null) {
        this.bindElement(element);
        return;
      }
      const elements = document.querySelectorAll(".oms-ui-state");
      const length = !elements ? 0 : elements.length;
      for (let i = 0; i < length; ++i) {
        this.loadState(elements[i]);
        this.bindElement(elements[i]);
      }
      for (let i = 0; i < length; ++i) {
        this.loadState(elements[i]);
      }
    }
    loadState(element) {
      if (!element) {
        return;
      }
      let state = JSON.parse(window.localStorage.getItem("ui-state-" + element.id));
      state = state !== null ? state : {};
      switch (element.tagName.toLowerCase()) {
        case "input":
          if (state === "1" && !element.checked || state === "0" && element.checked) {
            element.click();
          }
          break;
        case "div":
          element.scrollLeft = state.x;
          element.scrollTop = state.y;
          element.scrollTo({ top: state.y, left: state.x });
          break;
        default:
          break;
      }
    }
    /**
     * Bind DOM element
     *
     * @param {Element} element DOM element
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bindElement(element) {
      if (!element) {
        return;
      }
      switch (element.tagName.toLowerCase()) {
        case "input":
          element.addEventListener("change", function(event) {
            if (this.getAttribute("type") === "checkbox" || this.getAttribute("type") === "radio") {
              window.localStorage.setItem(
                "ui-state-" + this.id,
                JSON.stringify(this.checked ? "1" : "0")
              );
            } else {
              window.localStorage.setItem(
                "ui-state-" + this.id,
                JSON.stringify(this.value)
              );
            }
          });
          break;
        case "div":
          element.addEventListener("scroll", function() {
            window.localStorage.setItem(
              "ui-state-" + this.id,
              JSON.stringify({ x: this.scrollLeft, y: this.scrollTop })
            );
          });
          break;
        default:
          break;
      }
    }
  };

  // jsOMS/UI/UIManager.js
  var UIManager = class {
    /**
     * @constructor
     *
     * @param {Object} app Application object
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.app = app;
      this.formManager = new Form(this.app);
      this.tabManager = new Tab(this.app);
      this.tableManager = new Table(this.app);
      this.actionManager = new ActionManager(this.app);
      this.dragNDrop = new DragNDrop(this.app);
      this.order = new Order(this.app);
      this.generalUI = new GeneralUI(this.app);
      this.remoteData = new RemoteData(this.app);
      this.uiStateManager = new UIStateManager(this.app);
      const self2 = this;
      this.domObserver = new MutationObserver(function(mutations) {
        const length = mutations.length;
        for (let i = 0; i < length; ++i) {
          self2.app.eventManager.trigger(mutations[i].target.id + "-" + mutations[i].type, 0, mutations[i]);
        }
      });
    }
    /**
     * Bind & rebind UI elements.
     *
     * @param {string} [id] Element id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(id = null) {
      if (id === null) {
        this.formManager.bind();
        this.tabManager.bind();
        this.tableManager.bind();
        this.actionManager.bind();
        this.dragNDrop.bind();
        this.order.bind();
        this.generalUI.bind();
        this.remoteData.bind();
        this.uiStateManager.bind();
        return;
      }
      const tag = document.getElementById(id);
      this.generalUI.bind(tag);
      if (!tag) {
        return;
      }
      switch (tag.tagName) {
        case "form":
          this.formManager.bind(id);
          break;
        case "table":
          this.tableManager.bind(id);
          break;
        default:
          this.actionManager.bind(tag);
      }
    }
    /**
     * Get tab manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getFormManager() {
      return this.formManager;
    }
    /**
     * Get action manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getActionManager() {
      return this.actionManager;
    }
    /**
     * Get drag and drop manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getDragNDrop() {
      return this.dragNDrop;
    }
    /**
     * Get drag and drop manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getOrder() {
      return this.order;
    }
    /**
     * Get remote data manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getRemoteData() {
      return this.remoteData;
    }
    /**
     * Get remote data manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getUIStatemanager() {
      return this.uiStateManager;
    }
    /**
     * Get tab manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getTabManager() {
      return this.tabManager;
    }
    /**
     * Get table manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getTableManager() {
      return this.tabManager;
    }
    /**
     * Get DOM observer
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getDOMObserver() {
      return this.domObserver;
    }
    /**
     * Get general UI
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getGeneralUI() {
      return this.generalUI;
    }
  };

  // jsOMS/UI/Input/Keyboard/KeyboardManager.js
  var KeyboardManager = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.elements = {};
      this.down = [];
    }
    /**
     * Add input listener.
     *
     * @param {string}   element  Container id
     * @param {Array}    keys     Keyboard keys
     * @param {function} callback Callback
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    add(element, keys, callback) {
      if (typeof this.elements[element] === "undefined") {
        this.elements[element] = [];
        this.bind(element);
      }
      this.elements[element].push({ keys, callback });
    }
    /**
     * Bind container for keyboard input.
     *
     * @param {string} element Container id
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(element) {
      const self2 = this;
      const elements = element === "" ? [document] : document.querySelectorAll(element);
      const length = elements.length;
      for (let i = 0; i < length; ++i) {
        elements[i].addEventListener("keydown", function(event) {
          self2.down.push(event.keyCode);
          self2.run(element, event);
        });
        elements[i].addEventListener("keyup", function(event) {
          let index = self2.down.indexOf(event.keyCode);
          while (index > -1) {
            self2.down.splice(index, 1);
            index = self2.down.indexOf(event.keyCode);
          }
        });
      }
    }
    /**
     * Execute callback based on key presses.
     *
     * @param {string} element Container id
     * @param {Event}  event   Key event
     *
     * @return {void}
     *
     * @throws {Error}
     *
     * @since 1.0.0
     */
    run(element, event) {
      if (typeof this.elements[element] === "undefined") {
        throw new Error("Unexpected elmenet!");
      }
      const actions = this.elements[element].concat(this.elements[""]);
      const actionsLength = actions.length;
      const downKeyLength = this.down.length;
      for (let i = 0; i < actionsLength; ++i) {
        const actionKeyLength = actions[i].keys.length;
        let match = true;
        for (let j = 0; j < actionKeyLength; ++j) {
          if (this.down.indexOf(actions[i].keys[j]) === -1) {
            match = false;
            break;
          }
        }
        if (match) {
          for (let j = 0; j < downKeyLength; ++j) {
            if (actions[i].keys.indexOf(this.down[j]) === -1) {
              match = false;
              break;
            }
          }
        }
        if (match) {
          jsOMS2.preventAll(event);
          actions[i].callback(event);
          break;
        }
      }
    }
  };

  // jsOMS/UI/Input/Mouse/EventType.js
  var EventType = Object.freeze({
    CONTEXT: 0,
    LONGPRESS: 1,
    CLICK: 2
  });

  // jsOMS/UI/Input/Mouse/MouseManager.js
  var MouseManager = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.elements = {};
      this.click = { time: 0 };
    }
    /**
     * Add input listener.
     *
     * @param {string}   element Container id
     * @param {number}   type Action type
     * @param {number}   button Button
     * @param {function} callback Callback
     * @param {boolean}  exact ??? todo: can't remember why this was important oO!!!
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    add(element, type, button, callback, exact) {
      if (typeof this.elements[element] === "undefined") {
        this.elements[element] = [];
      }
      this.bind(element, type);
      this.elements[element].push({ callback, type, button, exact });
    }
    /**
     * Add input listener.
     *
     * @param {string} element Element id
     * @param {number} type Action type
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    bind(element, type) {
      const self2 = this;
      const e = document.getElementById(element);
      if (!e) {
        return;
      }
      if (type === EventType.CONTEXT) {
        e.addEventListener("contextmenu", function(event) {
          self2.run(element, event);
        }, false);
      } else if (type === EventType.LONGPRESS) {
        e.addEventListener("mousedown", function(event) {
          self2.click.time = (/* @__PURE__ */ new Date()).getTime();
        }, false);
        e.addEventListener("mouseup", function(event) {
          const duration = (/* @__PURE__ */ new Date()).getTime() - self2.click.time;
          if (duration > 650) {
            self2.run(element, event);
          }
          self2.click.time = 0;
        }, false);
      } else if (type === EventType.CLICK) {
        e.addEventListener("click", function(event) {
          self2.run(element, event);
        }, false);
      }
    }
    /**
     * Run mouse input callback.
     *
     * @param {string} element Element id
     * @param {Event}  event Click event
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    run(element, event) {
      if (typeof this.elements[element] === "undefined") {
        throw new Error("Unexpected element!");
      }
      const actions = this.elements[element];
      const length = actions.length;
      for (let i = 0; i < length; ++i) {
        if ((!actions[i].exact || event.target.getAttribute("id") === element) && actions[i].button === event.button) {
          jsOMS2.preventAll(event);
          actions[i].callback();
        }
      }
    }
  };

  // jsOMS/UI/Input/Voice/VoiceManager.js
  var VoiceManager = class {
    /**
     * @constructor
     *
     * @param {Object} app      Application
     * @param {Object} commands Available commands
     * @param {string} lang     Localization
     *
     * @since 1.0.0
     */
    constructor(app, commands = {}, lang = "en-US") {
      this.app = app;
      this.commands = commands;
      this.lang = lang;
      this.recognition = null;
      this.speechRecognitionList = null;
      if (SpeechRecognition !== null) {
        this.recognition = new SpeechRecognition();
        this.speechRecognitionList = new SpeechGrammarList();
      }
    }
    /**
     * Setup or re-initialize voice manager.
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setup() {
      if (SpeechRecognition === null) {
        return;
      }
      const self2 = this;
      this.recognition.lang = this.lang;
      this.recognition.interimResults = false;
      this.recognition.maxAlternatives = 1;
      this.recognition.continuous = true;
      this.recognition.lang = this.lang;
      if (typeof this.commands !== "undefined") {
        this.speechRecognitionList.addFromString(this.getCommandsString(), 1);
        this.recognition.grammars = this.speechRecognitionList;
      }
      this.recognition.onstart = function() {
      };
      this.recognition.onresult = function(event) {
        const result = jsOMS2.trim(event.results[event.resultIndex][0].transcript);
        const commands = Object.keys(self2.commands);
        for (const command of commands) {
          if (result.startsWith(command)) {
            self2.commands[command](result.substr(command.length).trim());
          }
        }
      };
      this.recognition.onspeechend = function() {
      };
      this.recognition.onnomatch = function(event) {
        Logger2.instance.warning("Couldn't recognize speech");
      };
      this.recognition.onerror = function(event) {
        Logger2.instance.warning("Error during speech recognition: " + event.error);
      };
    }
    /**
     * Create commands/grammar string from commands
     *
     * @return {string}
     *
     * @since 1.0.0
     */
    getCommandsString() {
      return "#JSGF V1.0; grammar phrase; public <phrase> = " + Object.keys(this.commands).join(" | ") + " ;";
    }
    /**
     * Set language
     *
     * @param {string} lang Language code (e.g. en-US)
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setLanguage(lang) {
      this.recognition.lang = lang;
    }
    /**
     * Add command/grammar and callback.
     *
     * @param {string} command Command id
     * @param {callback} callback Callback for command
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    add(command, callback) {
      this.commands[command] = callback;
    }
    /**
     * Start voice listener.
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    start() {
      if (SpeechRecognition === null) {
        return;
      }
      this.recognition.start();
    }
    /**
     * Stop voice listener.
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    stop() {
      if (SpeechRecognition === null) {
        return;
      }
      this.recognition.stop();
    }
  };
  var SpeechRecognition = typeof SpeechRecognition !== "undefined" ? SpeechRecognition : typeof webkitSpeechRecognition !== "undefined" ? webkitSpeechRecognition : null;
  var SpeechGrammarList = typeof SpeechGrammarList !== "undefined" ? SpeechGrammarList : typeof webkitSpeechGrammarList !== "undefined" ? webkitSpeechGrammarList : null;

  // jsOMS/UI/Input/InputManager.js
  var InputManager = class {
    /**
     * @constructor
     *
     * @param {Object} app Application
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.keyboardManager = new KeyboardManager();
      this.mouseManager = new MouseManager();
      this.voiceManager = new VoiceManager(app);
    }
    /**
     * Get keyboard manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getKeyboardManager() {
      return this.keyboardManager;
    }
    /**
     * Get mouse manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getMouseManager() {
      return this.mouseManager;
    }
    /**
     * Get voice manager.
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    getVoiceManager() {
      return this.voiceManager;
    }
  };

  // jsOMS/Module/ModuleFactory.js
  var ModuleFactory = class {
    /**
     * Get module instance.
     *
     * @param {string} module Module name
     * @param {Object} app    Application reference
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    static getInstance(module, app) {
      return new window.omsApp.Modules[module](app);
    }
  };

  // jsOMS/Module/ModuleManager.js
  var ModuleManager = class {
    /**
     * @constructor
     *
     * @param {Object} app Application
     *
     * @since 1.0.0
     */
    constructor(app) {
      this.modules = {};
      this.app = app;
    }
    /**
     * Get module.
     *
     * @param {string} module Module name
     *
     * @return {Object}
     *
     * @since 1.0.0
     */
    get(module) {
      if (typeof this.modules[module] === "undefined") {
        this.modules[module] = ModuleFactory.getInstance(module, this.app);
      }
      return this.modules[module];
    }
  };

  // jsOMS/UI/Input/Voice/ReadManager.js
  var ReadManager = class {
    /**
     * @constructor
     *
     * @param {string} lang Localization
     *
     * @since 1.0.0
     */
    constructor(lang = "en-US") {
      this.pitch = 1;
      this.rate = 1;
      this.lang = lang;
      this.voices = [];
      this.voice = null;
      if (SpeechRecognition2 !== null) {
        this.voices = window.speechSynthesis.getVoices();
        this.voice = this.voices[0];
      }
    }
    /**
     * Read text.
     *
     * @param {string} text Text to read
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    read(text) {
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = this.lang;
      utter.voice = this.voice;
      utter.pitch = this.pitch;
      utter.rate = this.rate;
      window.speechSynthesis.speak(utter);
    }
    /**
     * Set Language.
     *
     * @param {string} lang Language id (e.g. en-US)
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setLanguage(lang) {
      this.lang = lang;
    }
    /**
     * Set pitch.
     *
     * @param {int} pitch Pitch
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setPitch(pitch) {
      this.pitch = pitch;
    }
    /**
     * Set rate.
     *
     * @param {int} rate Rate
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setRate(rate) {
      this.rate = rate;
    }
    /**
     * Get supported voices.
     *
     * @return {Array}
     *
     * @since 1.0.0
     */
    getVoices() {
      return this.voices;
    }
  };
  var SpeechRecognition2 = typeof SpeechRecognition2 !== "undefined" ? SpeechRecognition2 : typeof webkitSpeechRecognition !== "undefined" ? webkitSpeechRecognition : null;

  // jsOMS/Message/Notification/App/AppNotification.js
  var AppNotification = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.status = 0;
    }
    /**
     * Set notification status.
     *
     * @param {number} status Notification status
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setStatus(status) {
      this.status = status;
    }
    /**
     * Create notification
     *
     * @param {NotificationMessage} msg Notification
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    send(msg) {
      const tpl = document.getElementById("app-message-tpl");
      if (tpl === null) {
        return;
      }
      switch (msg.status) {
        case 0:
          msg.status = NotificationLevel.OK;
          break;
      }
      ;
      const output = document.importNode(tpl.content, true);
      output.querySelector(".log-msg").classList.add("log-lvl-" + msg.status);
      output.querySelector(".log-msg-content").innerHTML = msg.message;
      output.querySelector(".close").addEventListener("click", function() {
        this.parentNode.remove();
      });
      if (msg.title && msg.title !== "") {
        output.querySelector(".log-msg-title").innerHTML = msg.title;
      } else {
        output.querySelector(".log-msg-title").remove();
      }
      if (!msg.primaryButton) {
        const primary = output.querySelector(".primary-button");
        if (primary) {
          primary.remove();
        }
      } else {
        const primary = output.querySelector(".primary-button");
        if (primary) {
          primary.innerHTML = msg.primaryButton.text;
          primary.addEventListener("click", msg.primaryButton.callback);
        }
      }
      if (!msg.secondaryButton) {
        const secondary = output.querySelector(".secondary-button");
        if (secondary) {
          secondary.remove();
        }
      } else {
        const secondary = output.querySelector(".secondary-button");
        if (secondary) {
          secondary.innerHTML = msg.secondaryButton.text;
          secondary.addEventListener("click", msg.secondaryButton.callback);
        }
      }
      tpl.parentNode.appendChild(output);
      const logs = document.getElementsByClassName("log-msg");
      const lastElementAdded = logs[logs.length - 1];
      window.navigator.vibrate(msg.vibrate ? 200 : 0);
      if (msg.isSticky) {
        return;
      }
      setTimeout(function() {
        if (lastElementAdded !== null && lastElementAdded.parentNode !== null) {
          lastElementAdded.parentNode.removeChild(lastElementAdded);
        }
      }, msg.duration);
    }
  };

  // jsOMS/Message/Notification/Browser/BrowserNotification.js
  var BrowserNotification = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.status = 0;
    }
    /**
     * Set notification status.
     *
     * @param {number} status Notification status
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setStatus(status) {
      this.status = status;
    }
    /**
     * Ask for browser permission to create notifications
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    requestPermission() {
      if (Notification.permission !== "granted" && Notification.permission !== "denied" && window.isSecureContext) {
        Notification.requestPermission();
      }
    }
    /**
     * Create notification
     *
     * @param {NotificationMessage} msg Notification
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    send(msg) {
      if (Notification.permission !== "granted") {
        return;
      }
      navigator.serviceWorker.ready.then((registration) => {
        registration.showNotification(msg.title, {
          body: msg.message,
          icon: "../images/touch/chrome-touch-icon-192x192.png",
          vibrate: [msg.vibrate ? 200 : 0],
          tag: "notification"
        });
      });
    }
  };

  // jsOMS/Message/Notification/NotificationManager.js
  var NotificationManager = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.appNotifier = new AppNotification();
      this.browserNotifier = new BrowserNotification();
    }
    /**
     * Create notification.
     *
     * @param {Object} message Message object
     * @param {number} type    Notification type
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    send(message, type) {
      if (NotificationType.APP_NOTIFICATION === type) {
        this.appNotifier.send(message);
      } else {
        this.browserNotifier.send(message);
      }
    }
    /**
     * Get the app notification manager.
     *
     * @return {AppNotification}
     *
     * @since 1.0.0
     */
    getAppNotifier() {
      return this.appNotifier;
    }
    /**
     * Get the browser notification manager.
     *
     * @return {BrowserNotification}
     *
     * @since 1.0.0
     */
    getBrowserNotifier() {
      return this.browserNotifier;
    }
  };

  // jsOMS/Model/Action/Dom/Redirect.js
  function redirectMessage(action, callback, id) {
    setTimeout(function() {
      if (action.src) {
        document.getElementById(action.src).src = UriFactory.build(action.uri);
      } else {
        window.location = UriFactory.build(action.uri);
      }
    }, parseInt(action.delay));
  }

  // jsOMS/Model/Action/Message/Request.js
  function requestAction(action, callback) {
    "use strict";
    const request = new Request(action.uri, action.method, action.request_type);
    request.setSuccess(function(xhr) {
      window.omsApp.logger.log(xhr.responseText);
      callback(JSON.parse(xhr.responseText));
    });
    if (typeof action.data !== "undefined" && action.data !== null) {
      request.setData(action.data);
    }
    request.send();
  }

  // jsOMS/Model/Action/Dom/Reload.js
  function reloadButtonAction(action, callback, id) {
    "use strict";
    setTimeout(function() {
      if (action.src) {
        console.log(document.getElementById(action.src).hasAttribute("data-src"));
        console.log(UriFactory.build(document.getElementById(action.src).getAttribute("data-src")));
        document.getElementById(action.src).src = document.getElementById(action.src).hasAttribute("data-src") ? UriFactory.build(document.getElementById(action.src).getAttribute("data-src")) : document.getElementById(action.src).src;
      } else {
        document.location.reload();
      }
    }, parseInt(action.delay));
    callback();
  }

  // jsOMS/Model/Action/Event/Prevent.js
  function preventEvent(action, callback, id) {
    "use strict";
    window.omsApp.logger.log("prevented");
    jsOMS2.preventAll(action.data);
    callback();
  }

  // jsOMS/Model/Action/Event/Jump.js
  function jumpAction(action, callback, id) {
    "use strict";
    action.key = action.jump - 1;
    callback();
  }

  // jsOMS/Model/Action/Event/If.js
  function ifAction(action, callback, id) {
    "use strict";
    const conditions = action.conditions;
    const data = Object.values(action.data)[0];
    for (const i in conditions) {
      if (conditions[i].comp === "==" && data === conditions[i].value) {
        action.key = conditions[i].jump - 1;
        break;
      } else if (conditions[i].comp === "!=" && data !== conditions[i].value) {
        action.key = conditions[i].jump - 1;
        break;
      } else if (conditions[i].comp === ">" && data > conditions[i].value) {
        action.key = conditions[i].jump - 1;
        break;
      } else if (conditions[i].comp === "<" && data < conditions[i].value) {
        action.key = conditions[i].jump - 1;
        break;
      } else if (conditions[i].comp === ">=" && data >= conditions[i].value) {
        action.key = conditions[i].jump - 1;
        break;
      } else if (conditions[i].comp === "<=" && data <= conditions[i].value) {
        action.key = conditions[i].jump - 1;
        break;
      } else if (conditions[i].comp === "") {
        action.key = conditions[i].jump - 1;
        break;
      }
    }
    callback();
  }

  // jsOMS/Model/Action/Dom/Click.js
  function domClickAction(action, callback, id) {
    "use strict";
    const click = action.base === "self" ? action.selector === "" ? [document.getElementById(id)] : document.getElementById(id).querySelectorAll(action.selector) : document.querySelectorAll(action.selector);
    if (!click) {
      return;
    }
    for (const i of click) {
      i.click();
    }
    callback();
  }

  // jsOMS/Model/Action/Dom/GetValue.js
  function domGetValue(action, callback, id) {
    "use strict";
    const e = action.base === "self" ? action.selector === "" || typeof action.selector === "undefined" ? [document.getElementById(id)] : document.getElementById(id).querySelectorAll(action.selector) : document.querySelectorAll(action.selector);
    let value = {};
    for (const i in e) {
      if (!Object.prototype.hasOwnProperty.call(e, i) || !(e[i] instanceof HTMLElement)) {
        continue;
      }
      const eId = typeof e[i].getAttribute("name") !== "undefined" && e[i].getAttribute("name") !== "" && e[i].getAttribute("name") !== null ? e[i].getAttribute("name") : e[i].getAttribute("id");
      if (e[i].tagName.toLowerCase() === "form") {
        value = window.omsApp.uiManager.getFormManager().get(eId).getData();
        break;
      } else {
        value[eId] = GeneralUI.getValueFromDataSource(e[i]);
      }
    }
    callback(value);
  }

  // jsOMS/Model/Action/Dom/SetValue.js
  function domSetValue(action, callback, id) {
    "use strict";
    let dataPath = action.value;
    let path = "";
    let tempDataValue = "";
    let replaceText = "";
    let start = 0;
    let end = 0;
    while (dataPath.indexOf("http") !== 0 && (start = dataPath.indexOf("{", start)) !== -1) {
      end = dataPath.indexOf("}", start);
      start++;
      path = dataPath.substring(start, end);
      tempDataValue = jsOMS2.getArray(path, action.data, "/");
      replaceText = "{" + path + "}";
      dataPath = dataPath.replace(new RegExp(replaceText.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), tempDataValue);
    }
    const fill = action.base === "self" ? action.selector === "" ? [document.getElementById(id)] : document.getElementById(id).querySelectorAll(action.selector) : document.querySelectorAll(action.selector);
    for (const i in fill) {
      if (!Object.prototype.hasOwnProperty.call(fill, i) || !(fill[i] instanceof HTMLElement)) {
        continue;
      }
      if (fill[i].tagName.toLowerCase() === "div" || fill[i].tagName.toLowerCase() === "span") {
        if (!fill[i].innerHTML.includes(dataPath)) {
          if (action.overwrite) {
            fill[i].innerHTML = dataPath;
          } else if (!action.overwrite) {
            fill[i].innerHTML += dataPath;
          }
        }
      } else if (fill[i].tagName.toLowerCase() === "iframe") {
        fill[i].src = UriFactory.build(dataPath);
      } else {
        if (fill[i].value !== dataPath && !fill[i].value.includes(", " + dataPath + ",") && !fill[i].value.endsWith(", " + dataPath) && !fill[i].value.startsWith(dataPath + ",")) {
          if (action.overwrite) {
            fill[i].value = dataPath;
          } else {
            fill[i].value += (fill[i].value !== "" ? ", " : "") + dataPath;
          }
        }
      }
    }
    callback(action.data);
  }

  // jsOMS/Model/Action/Dom/ChangeAttribute.js
  function domChangeAttribute(action, callback, id) {
    "use strict";
    const fill = action.base === "self" ? action.selector === "" ? [document.getElementById(id)] : document.getElementById(id).querySelectorAll(action.selector) : document.querySelectorAll(action.selector);
    for (const i in fill) {
      if (!Object.prototype.hasOwnProperty.call(fill, i) || !(fill[i] instanceof HTMLElement)) {
        continue;
      }
      switch (action.subtype) {
        case "remove":
          const old = fill[i].getAttribute(action.attr);
          if (old !== null && old.match(new RegExp("(\\s|^)" + action.value + "(\\s|$)")) !== null) {
            const reg = new RegExp("(\\s|^)" + action.value);
            fill[i].setAttribute(action.attr, old.replace(reg, "").trim());
          }
          break;
        case "add":
          fill[i].setAttribute(action.attr, jsOMS2.trim(fill[i].getAttribute(action.attr) + " " + action.value));
          break;
        case "set":
          fill[i].setAttribute(action.attr, action.value);
          break;
        default:
      }
    }
    callback(action.data);
  }

  // jsOMS/Model/Action/Dom/FormSubmit.js
  function formSubmitAction(action, callback, id) {
    "use strict";
    const submit = action.base === "self" ? action.selector === "" ? [document.getElementById(id)] : document.getElementById(id).querySelectorAll(action.selector) : document.querySelectorAll(action.selector);
    if (!submit) {
      return;
    }
    const formManager = window.omsApp.uiManager.getFormManager();
    for (const i of submit) {
      formManager.submit(formManager.get(i.id));
    }
    callback();
  }

  // Install/Application/Backend/js/global/ActionEvents.js
  var ACTION_EVENTS = {
    "redirect": redirectMessage,
    /** global: redirectMessage */
    "message.request": requestAction,
    /** global: requestAction */
    "dom.reload": reloadButtonAction,
    /** global: reloadButtonAction */
    "dom.click": domClickAction,
    /** global: domClickAction */
    "form.submit": formSubmitAction,
    /** global: domClickAction */
    "event.prevent": preventEvent,
    /** global: preventEvent */
    "dom.get": domGetValue,
    /** global: domGetValue */
    "dom.set": domSetValue,
    /** global: domSetValue */
    "dom.attr.change": domChangeAttribute,
    /** global: domChangeAttribute */
    "jump": jumpAction,
    /** global: jumpAction */
    "if": ifAction
    /** global: ifAction */
  };

  // Install/Application/Backend/js/global/KeyboardEvents.js
  var KEYBOARD_EVENTS = [
    {
      "element": "",
      // jump into search bar
      "keys": [17, 80],
      // ctrl+p
      "callback": function(e) {
        document.getElementById("iSearchBox").focus();
      }
    },
    {
      "element": "form, input, textarea, select",
      // submit currently focused form with the first found submit element (add, update, save)
      "keys": [17, 13],
      // ctrl+enter
      "callback": function(e) {
        const focused = document.activeElement;
        let formId = focused.closest("form");
        if (formId !== null) {
          formId = formId.id;
        }
        if (formId === null) {
          formId = focused.getAttribute("form");
        }
        if (formId === null) {
          formId = focused.getAttribute("data-form");
        }
        if (formId === null) {
          return;
        }
        const form = window.omsApp.uiManager.getFormManager().get(formId);
        const buttons = form.getSubmit();
        const length = buttons.length;
        let defaultSubmit = -1;
        for (let i = 0; i < length; ++i) {
          if (jsOMS2.hasClass(buttons[i], "vh")) {
            continue;
          }
          if (jsOMS2.hasClass(buttons[i], "add-form") || jsOMS2.hasClass(buttons[i], "update-form") || jsOMS2.hasClass(buttons[i], "save-form")) {
            buttons[i].click();
            break;
          }
          defaultSubmit = i;
        }
        if (defaultSubmit !== -1) {
          buttons[defaultSubmit].click();
        }
      }
    },
    {
      "element": "label, tr",
      // click label
      "keys": [13],
      // enter
      "callback": function(e) {
        document.activeElement.click();
      }
    },
    {
      "element": "",
      // previous page
      "keys": [17, 66],
      // ctrl+b
      "callback": function(e) {
        window.history.back();
      }
    },
    {
      "element": "",
      // next tabindex
      "keys": [17, 40],
      // ctrl+down
      "callback": function(e) {
        const focusable = document.querySelectorAll('button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
        const length = focusable.length;
        for (let i = 0; i < length; ++i) {
          if (document.activeElement === focusable[i]) {
            let j = 1;
            do {
              if (i + j < length) {
                focusable[i + j].focus();
              } else {
                focusable[0 + j - 1].focus();
              }
              ++j;
            } while (j < length && document.activeElement === focusable[i]);
            return;
          }
        }
        document.dispatchEvent(new KeyboardEvent("keypress", { keyCode: 9 }));
      }
    },
    {
      "element": "",
      // previous tab index
      "keys": [17, 38],
      // ctrl+up
      "callback": function(e) {
        const focusable = document.querySelectorAll('button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
        const length = focusable.length;
        for (let i = 0; i < length; ++i) {
          if (document.activeElement === focusable[i]) {
            let j = 1;
            do {
              if (i - j + 1 > 0) {
                focusable[i - j].focus();
              } else {
                focusable[length - j].focus();
              }
              ++j;
            } while (j < length && document.activeElement === focusable[i]);
            return;
          }
        }
        document.dispatchEvent(new KeyboardEvent("keypress", { keyCode: 9 }));
      }
    }
  ];

  // jsOMS/UI/Input/Mouse/ClickType.js
  var ClickType = Object.freeze({
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
  });

  // Install/Application/Backend/js/global/MouseEvents.js
  var MOUSE_EVENTS = [
    {
      "element": "nav-side",
      "type": EventType.CONTEXT,
      "button": ClickType.RIGHT,
      "callback": function() {
        window.omsApp.logger.log("right clicked");
      },
      "exact": true
    },
    {
      "element": "nav-side",
      "type": EventType.LONGPRESS,
      "button": ClickType.LEFT,
      "callback": function() {
        window.omsApp.logger.log("left clicked");
      },
      "exact": false
    }
  ];

  // jsOMS/Model/Message/Notify.js
  function notifyMessage(data) {
    const msg = new NotificationMessage(data.level, data.title, data.msg);
    msg.duration = 5e3;
    window.omsApp.notifyManager.send(
      msg,
      NotificationType.APP_NOTIFICATION
    );
  }

  // jsOMS/Model/Message/FormValidation.js
  function formValidationMessage(data) {
    const form = document.getElementById(data.form);
    if (!form) {
      return;
    }
    const eEles = document.getElementsByClassName("i-" + data.form);
    while (eEles.length > 0) {
      eEles[0].parentNode.removeChild(eEles[0]);
    }
    ;
    data.errors.forEach(function(error) {
      const eEle = document.getElementById(error.id);
      if (!eEle) {
        return;
      }
      const msgEle = document.createElement("i");
      const msg = document.createTextNode(error.msg);
      msgEle.id = "i-" + error.id;
      msgEle.class = "i-" + data.form;
      msgEle.appendChild(msg);
      eEle.parentNode.insertBefore(msgEle, eEle.nextSibling);
    });
  }

  // Install/Application/Backend/js/global/ResponseEvents.js
  var RESPONSE_EVENTS = {
    "notify": notifyMessage,
    /** global: notifyMessage */
    "validation": formValidationMessage,
    /** global: formValidationMessage */
    "redirect": redirectMessage,
    /** global: redirectMessage */
    "reload": reloadButtonAction
    /** global: reloadButtonAction */
  };

  // Install/Application/Backend/js/global/VoiceEvents.js
  var VOICE_EVENTS = {
    "read": "read_text",
    "help": function() {
      Logger2.instance.debug("There is no help for you.");
    },
    "go to": function(speech) {
      const request = new Request();
      request.setData({});
      request.setType(RequestType.FORM_DATA);
      request.setUri("api/navigation/goto?app=Backend&search=" + speech);
      request.setMethod(RequestMethod.GET);
      request.setSuccess(function(xhr) {
        window.omsApp.logger.log(xhr.response);
        try {
          const o = JSON.parse(xhr.response)[0];
          const response = new Response(o);
          if (typeof response.get("type") !== "undefined") {
            window.omsApp.responseManager.run(response.get("type"), response.get(), request);
          } else if (typeof o.status !== "undefined" && o.status !== NotificationLevel.HIDDEN) {
            window.omsApp.notifyManager.send(
              new NotificationMessage(o.status, o.title, o.message),
              NotificationType.APP_NOTIFICATION
            );
          }
        } catch (e) {
          window.omsApp.logger.log(e);
          Logger2.instance.error(
            "Invalid form response. \nRequest: " + JSON.stringify(speech) + "\nResponse: " + xhr.response
          );
        }
      });
      request.setResultCallback(0, function(xhr) {
        window.omsApp.notifyManager.send(
          new NotificationMessage(
            NotificationLevel.ERROR,
            "Failure",
            "Some failure happened"
          ),
          NotificationType.APP_NOTIFICATION
        );
      });
      request.send();
    }
  };

  // Install/Application/Backend/js/backend.js
  var Application = class {
    /**
     * @constructor
     *
     * @since 1.0.0
     */
    constructor() {
      this.logger = Logger2.getInstance(true, false, false);
      window.logger = this.logger;
      this.cacheManager = new CacheManager();
      this.storageManager = new StorageManager();
      this.eventManager = new EventManager();
      this.responseManager = new ResponseManager();
      this.assetManager = new AssetManager();
      this.accountManager = new AccountManager();
      this.uiManager = new UIManager(this);
      this.inputManager = new InputManager(this);
      this.moduleManager = new ModuleManager(this);
      this.readManager = new ReadManager();
      this.voiceManager = new VoiceManager(this);
      this.notifyManager = new NotificationManager();
      this.request = null;
      this.state = {
        hasChanges: false
      };
      this.reInit();
      this.setupGeolocation();
      this.setupNotificationManager();
      this.setupServiceWorker();
      this.setResponseMessages();
      this.setVoiceActions();
      this.setActions();
      this.setKeyboardActions();
      this.setMouseActions();
      this.setPopstate();
    }
    reInit() {
      this.request = new HttpUri(window.location.href);
      this.request.setRootPath(
        HttpUri.parseUrl(
          typeof document.getElementsByTagName("base")[0] !== "undefined" ? document.getElementsByTagName("base")[0].href : ""
        ).path
      );
      UriFactory.setupUriBuilder(this.request);
      UriFactory.setQuery("/lang", window.location.href.substr(this.request.getBase().length).split("/")[0]);
      this.uiManager.bind();
    }
    setPopstate() {
      window.addEventListener("popstate", function(event, state) {
        window.location.href = window.location.href;
      });
    }
    setupGeolocation() {
      if ("geolocation" in navigator && window.isSecureContext) {
        navigator.geolocation.getCurrentPosition((position) => {
        });
      }
    }
    setupNotificationManager() {
      this.notifyManager.browserNotifier.requestPermission();
    }
    /**
     * Setup the service worker
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setupServiceWorker() {
      if ("serviceWorker" in navigator && window.isSecureContext) {
        navigator.serviceWorker.register("sw.min.js").then(function(e) {
          self.periodicSync.register("get-latest-notification", {
            minInterval: 60 * 1
          }).then(() => {
            Logger2.instance.warning("PeriodicSync registration worked.");
          }).catch(function(e2) {
            Logger2.instance.warning("PeriodicSync registration failed.");
          });
        }).catch(function(e) {
          Logger2.instance.warning("ServiceWorker registration failed.");
        });
      }
    }
    /**
     * Setup the response manager
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setResponseMessages() {
      for (let key in RESPONSE_EVENTS) {
        if (RESPONSE_EVENTS.hasOwnProperty(key)) {
          this.responseManager.add(key, RESPONSE_EVENTS[key]);
        }
      }
    }
    /**
     * Setup the action manager
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setActions() {
      for (let key in ACTION_EVENTS) {
        if (ACTION_EVENTS.hasOwnProperty(key)) {
          this.uiManager.getActionManager().add(key, ACTION_EVENTS[key]);
        }
      }
    }
    /**
     * Setup the keyboard manager
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setKeyboardActions() {
      let length = KEYBOARD_EVENTS.length;
      for (let i = 0; i < length; i++) {
        this.inputManager.getKeyboardManager().add(
          KEYBOARD_EVENTS[i]["element"],
          KEYBOARD_EVENTS[i]["keys"],
          KEYBOARD_EVENTS[i]["callback"]
        );
      }
    }
    /**
     * Setup the mouse manager
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setMouseActions() {
      let length = MOUSE_EVENTS.length;
      for (let i = 0; i < length; i++) {
        this.inputManager.getMouseManager().add(
          MOUSE_EVENTS[i]["element"],
          MOUSE_EVENTS[i]["type"],
          MOUSE_EVENTS[i]["button"],
          MOUSE_EVENTS[i]["callback"],
          MOUSE_EVENTS[i]["exact"]
        );
      }
    }
    /**
     * Setup the voice manager
     *
     * @return {void}
     *
     * @since 1.0.0
     */
    setVoiceActions() {
      for (let key in VOICE_EVENTS) {
        if (VOICE_EVENTS.hasOwnProperty(key)) {
          this.voiceManager.add(key, VOICE_EVENTS[key]);
        }
      }
      this.voiceManager.setup();
      this.voiceManager.start();
    }
  };
  jsOMS2.ready(function() {
    "use strict";
    window.omsApp = new Application();
  });
})();
/**
 * Standard library
 *
 * This library provides useful functionalities for the DOM and other manipulations.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Asset manager.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Log Level enum.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Http Uri.
 *
 * This class is for creating, modifying and analyzing http uris.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Response manager class.
 *
 * Used for auto handling different responses.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Http request method.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Response type enum.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Form manager class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Form view.
 *
 * The form view contains a single form and it's data elements. Form actions are no longer handled by
 * the browser but through this view. The view also provides additional functionality for non-default
 * form elements such as canvas etc.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 *
 * @tood Karaka/jsOMS#60
 *  On change listener
 *  Allow to add a on change listener in a form. This should result in automatic submits after changing a form.
 *  Consider the following cases to submit the form:
 *      * on Enter (all except textarea)
 *      * on Change (by using a timer)
 *      * on Leave (all elements)
 *  The listener should be defined in the form definition once and in js be applied to all form elements.
 */
/**
 * Uri factory.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Request type enum.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Request class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 *
 * @question Consider to completely remove and replace with fetch
 */
/**
 * Request data enum.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * System utils class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Logger class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Request manager class.
 *
 * Used for pooling requests.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Account Manager.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Notification data enum.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * App notification message.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Advanced input class.
 *
 * @copyright  Dennis Eichhorn
 * @license    OMS License 2.0
 * @version    1.0.0
 * @since      1.0.0
 */
/**
 * UI manager for handling basic ui elements.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Form manager class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 *
 * @todo Adding a template to the DOM should modify its id/generate a custom/random id for the added element
 *      for future handling as very often ids are required to identify and manage UI elements.
 *      https://github.com/Karaka-Management/jsOMS/issues/102
 *
 * @feature Auto update data changes in the backend (e.g. pull every x seconds, or use websockets for push)
 *      https://github.com/Karaka-Management/Karaka/issues/151
 */
/**
 * Tab manager class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Table view.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 *
 * @todo Karaka/jsOMS#50
 *  Add basic table handling (no db and pagination)
 *
 * @todo Karaka/jsOMS#55
 *  Implement filtering and sorting based on backend
 *
 * @todo Karaka/jsOMS#57
 *  Advanced filtering
 *  The current filtering implementation is only column by column connected with &&.
 *  Consider to implement a much more advanced filtering where different combinations are possible such as || &&, different ordering with parenthesis etc.
 *  This can be extremely powerful but will be complex for standard users.
 *  This advanced filtering should probably be a little bit hidden?
 *
 * @todo Karaka/jsOMS#59
 *  Data download
 *  There is a small icon in the top right corner of tables which allows (not yet to be honest) to download the data in the table.
 *  Whether the backend should be queried for this or only the frontend data should be collected (current situation) should depend on if the table has an api endpoint defined.
 */
/**
 * Table manager class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 *
 * @feature Karaka/jsOMS#55
 *      Implement filtering and sorting based on backend
 *
 * @feature Karaka/jsOMS#57
 *      Advanced filtering
 *      The current filtering implementation is only column by column connected with &&.
 *      Consider to implement a much more advanced filtering where different combinations are possible such as || &&, different ordering with parenthesis etc.
 *      This can be extremely powerful but will be complex for standard users.
 *      This advanced filtering should probably be a little bit hidden?
 *
 * @feature Karaka/jsOMS#59
 *      Data download
 *      There is a small icon in the top right corner of tables which allows (not yet to be honest) to download the data in the table.
 *      Whether the backend should be queried for this or only the frontend data should be collected (current situation) should depend on if the table has an api endpoint defined.
 *
 * @feature Allow column drag/drop ordering which is also saved in the front end
 *
 * @feature Implement a filter highlight function.
 *      Either in forms or in tables, where the filter icon is highlighted, if a filter is defined.
 *      One solution could be to put an additional hidden filter checkbox in front of the filter icon and check for filter changes
 *      (bubble up) and then activate this hidden checkbox if a filter is defined.
 *      In CSS just define the filter icon as active/highlighted, if the hidden check box is active.
 *      This means we have two hidden checkboxes in front of the filter icon (one in case the filter menu is open = popup
 *      is visible and another one for highlighting the filter icon if a filter is defined).
 *      https://github.com/Karaka-Management/Karaka/issues/148
 *
 * @todo How to preserve form filter data to the next page?
 *      Not an issue, in the future we don't want to reload the whole page,
 *      but only exchange the table/list content with the backend response -> the header/filter will not get changed and
 *      remains as defined. This means for tables (maybe even forms?) to setup content replacement earlier than for other pages?!
 *      https://github.com/Karaka-Management/Karaka/issues/149
 */
/**
 * Action manager class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 *
 * @todo Karaka/jsOMS#26
 *  Sync/Async events
 *  Events so far can be created sync and async depending on the implementation.
 *  It would be better to make it sync/async depending on a option flag.
 *
 * @todo Karaka/jsOMS#35
 *  Template actions cannot be overwritten
 *  Templates by nature get added and removed from a page (often in order to reuse existing html to minimize the html load).
 *  The problem with templates is that they need to register in the ActionManager.js.
 *  A listener currently is only registered once per id.
 *  Since templates often keep the same id for some elements this results in a problem because the new template will not register a new listener.
 *  Possible solutions:
 *      1. Force unique ids for templates during setup (pro: fast and easy initial solution, con: action event pollution not solved)
 *      2. Whenever a dom element with action elements is removed, also unregister the listeners (pro: clean solution, con: difficult to implement)
 *  Solution 2 will be implemented.
 *  Maybe this can be performed in the dom removing action events or a dom listener would be required to listen for these dom elements.
 */
/**
 * Drag and drop class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Manual order class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Remote data class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * UI state manager class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Keyboard manager class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Event type.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Mouse manager class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Voice manager class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * UI manager class.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Module factory.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Module manager.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * App notification.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Browser notification.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Notification manager.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Click type.
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
/**
 * Application entry point
 *
 * @copyright Dennis Eichhorn
 * @license   OMS License 2.0
 * @version   1.0.0
 * @since     1.0.0
 */
